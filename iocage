#!/bin/sh
#-------------------------------------------------------------------------+
# Copyright (C) 2014 Peter Toth (pannon)
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

unset LC_ALL
unset LANG

PATH=${PATH}:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin

if [ "${1}" = "--version" -o "${1}" = "version" ] ; then
    echo "iocage 1.5.2 (2015/04/07)"
    exit 0
fi

# Check if the system has ZFS available. That is required for iocage to work properly.
# Exit if it doesn't.
if [ "$(zpool list)" = 'no pools available' ] ; then
    echo "  ERROR: ZFS is required for iocage to work and I can't find any pools available."
    exit 1
fi

# Auto UUID
uuid=$(uuidgen)

# pkg list, only used with the create subcommand
pkglist="none"

# Network defaults for jails start here

# detect VNET kernel and adjust jail default
# if supported turn it on by default
if [ ! -z $(sysctl -qn kern.features.vimage) ] ; then
    vnet="on"
else
    vnet="off"
fi

ipv6="on"

interfaces="vnet0:bridge0,vnet1:bridge1"
host_hostname=$uuid
exec_fib=0
hostname=$uuid
ip4_addr="none"
ip4_saddrsel="1"
ip4="new"
ip6_addr="none"
ip6_saddrsel="1"
ip6="new"
defaultrouter="none"
defaultrouter6="none"

# Standard jail properties
devfs_ruleset="4"
exec_start="/bin/sh /etc/rc"
exec_stop="/bin/sh /etc/rc.shutdown"
exec_prestart="/usr/bin/true"
exec_poststart="/usr/bin/true"
exec_prestop="/usr/bin/true"
exec_poststop="/usr/bin/true"
exec_clean=1
exec_timeout=60
stop_timeout=30
exec_jail_user=root
exec_system_jail_user=0
exec_system_user=root
mount_devfs=1
mount_fdescfs=1
enforce_statfs="2"
children_max="0"
login_flags='-f root'
securelevel="2"
host_hostuuid=$uuid
allow_set_hostname=1
allow_sysvipc=0
allow_raw_sockets=0
allow_chflags=0
allow_mount=0
allow_mount_devfs=0
allow_mount_nullfs=0
allow_mount_procfs=0
allow_mount_tmpfs=0
allow_mount_zfs=0
allow_quotas=0
allow_socket_af=0

# RCTL limits
cpuset="off"
rlimits="off"
memoryuse="8G:log"
memorylocked="off"
vmemoryuse="off"
maxproc="off"
cputime="off"
pcpu="off"
datasize="off"
stacksize="off"
coredumpsize="off"
openfiles="off"
pseudoterminals="off"
swapuse="off"
nthr="off"
msgqqueued="off"
msgqsize="off"
nmsgq="off"
nsemop="off"
nshm="off"
shmsize="off"
wallclock="off"

# Custom properties
iocroot="/iocage"
tag=$(date "+%F@%T")
template="no"
boot="off"
notes="none"
owner="root"
priority="99"
last_started="none"
type="jail"
release=$(uname -r|cut -f 1,2 -d'-')
hostid=$(cat /etc/hostid)
jail_zfs="off"
jail_zfs_dataset="iocage/jails/${uuid}/root/data"
mount_procfs="0"

# Native ZFS properties
compression="lz4"
origin="readonly"
quota="none"
mountpoint="readonly"
compressratio="readonly"
available="readonly"
used="readonly"
dedup="off"
reservation="none"

# Sync properties
sync_state="none"
sync_target="none"
sync_tgt_zpool="none"

# FTP variables
ftphost="ftp.freebsd.org"
ftpfiles="base.txz doc.txz lib32.txz src.txz"

# Resource limits
CONF_RCTL="memoryuse
           memorylocked
           vmemoryuse
           maxproc
           cputime
           pcpu
           datasize
           stacksize
           coredumpsize
           openfiles
           pseudoterminals
           swapuse
           nthr
           msgqqueued
           msgqsize
           nmsgq
           nsemop
           nshm
           shmsize
           wallclock"

# Networking configuration
CONF_NET="interfaces
          vnet
          host_hostname
          hostname
          ip4_addr
          ip4_saddrsel
          ip4
          ip6_addr
          ip6_saddrsel
          ip6
          defaultrouter
          defaultrouter6
          exec_fib"

# Native jail properties
CONF_JAIL="devfs_ruleset
           mount_devfs
           exec_start
           exec_stop
           exec_prestart
           exec_prestop
           exec_poststop
           exec_poststart
           exec_clean
           exec_timeout
           stop_timeout
           exec_jail_user
           exec_system_jail_user
           exec_system_user
           mount_fdescfs
           mount_procfs
           enforce_statfs
           children_max
           login_flags
           securelevel
           allow_set_hostname
           allow_sysvipc
           allow_raw_sockets
           allow_chflags
           allow_mount
           allow_mount_devfs
           allow_mount_nullfs
           allow_mount_procfs
           allow_mount_tmpfs
           allow_mount_zfs
           allow_quotas
           allow_socket_af
           host_hostuuid"

# Custom properties
CONF_CUSTOM="tag
             template
             rlimits
             boot
             notes
             owner
             priority
             last_started
             type
             hostid
             cpuset
             jail_zfs
             jail_zfs_dataset
             release"

# Native ZFS properties
CONF_ZFS="compression
          origin
          quota
          mountpoint
          compressratio
          available
          used
          dedup
          reservation"

# ZFS sync (not used yet)
CONF_SYNC="sync_stat
           sync_target
           sync_tgt_zpool"

# ftp properties
CONF_FTP="ftphost ftpdir"

# Basejail filesystems
bfs_list="bin
          boot
          lib
          libexec
          rescue
          sbin
          usr/bin
          usr/include
          usr/lib
          usr/libexec
          usr/sbin
          usr/share
          usr/src
          usr/libdata
          usr/lib32"

# Basejail directories
bdir_list="dev
           tmp
           var
           etc
           root
           proc
           mnt"


# Process command line options-------------------------
__parse_cmd () {
    while [ $# -gt 0 ] ; do
        case "$1" in
            list)       __list_jails "$2"
                        exit
                ;;
            console)    __console "$2"
                        exit
                ;;
            exec)       shift
                        __exec "$@"
                        exit
                ;;
            chroot)     __chroot "$2" "$3"
                        exit
                ;;
            defaults)   __print_defaults
                        exit
                ;;
            create)     __export_props "$@"
                        __create_jail "$@"
                        exit
                ;;
            destroy)    __destroy_jail "$2"
                        exit
                ;;
            clone)      __export_props "$@"
                        __clone_jail "$2"
                        exit
                ;;
            fetch)      __export_props "$@"
                        __fetch_release
                        exit
                ;;
            get)        __get_jail_prop "$2" "$3"
                        exit
                ;;
            set)        __export_props "$@"
                        __set_jail_prop "$2" "$3"
                        exit
                ;;
            start)      __start_jail "$2"
                        exit
                ;;
            stop)       __stop_jail "$2"
                        exit
                ;;
            restart)    __restart_jail "$2"
                        exit
                ;;
            rcboot)     __rc_jails boot
                        exit
                ;;
            rcshutdown) __rc_jails shutdown
                        exit
                ;;
            df)         __print_disk
                        exit
                ;;
            snapshot)   __snapshot "$2"
                        exit
                ;;
            snaplist)   __snaplist "$2"
                        exit
                ;;
            snapremove) __snapremove "$2"
                        exit
                ;;
            promote)    __promote "$2"
                        exit
                ;;
            rollback)   __rollback "$2"
                        exit
                ;;
            uncap)      __rctl_uncap "$2"
                        exit
                ;;
            cap)        __rctl_limits "$2"
                        exit
                ;;
            limits)     __rctl_list "$2"
                        exit
                ;;
            inuse)      __rctl_used "$2"
                        exit
                ;;
            runtime)    __runtime "$2"
                        exit
                ;;
            update)     __update "$2"
                        exit
                ;;
            upgrade)     __upgrade "$2"
                        exit
                ;;
            record)     __record "$2" "$3"
                        exit
                ;;
            package)    __package "$2"
                        exit
                ;;
            export)     __export "$2"
                        exit
                ;;
            import)     __export_props "$@"
                        __import "$2"
                        exit
                ;;
            show)       __show "$2"
                        exit
                ;;
            help)       __help
                        exit
                ;;
                *)      __usage
                        exit
                ;;
        esac
        shift
    done
}

# Print defaults set in this script---------------------------
__print_defaults () {
    CONF="$CONF_NET
          $CONF_JAIL
          $CONF_RCTL
          $CONF_CUSTOM
          $CONF_ZFS
          $CONF_SYNC
          $CONF_FTP"

    for prop in $(echo $CONF)  ; do
        prop_name=$prop
        eval prop="\$${prop}"
        if [ ! -z "$prop" ] ; then
            echo "$prop_name=$prop"
        fi
    done
}

# Print supported releases----------------------------------
__print_release () {
    supported="10.1-RELEASE
                9.3-RELEASE"

    echo "Supported releases are: "
    for rel in $(echo $supported) ; do
        printf "%15s\n" "$rel"
    done
}

__create_basejail () {
    local release="$1"
    local fs_list="bin
                   boot
                   lib
                   libexec
                   rescue
                   sbin
                   usr
                   usr/bin
                   usr/include
                   usr/lib
                   usr/libexec
                   usr/sbin
                   usr/share
                   usr/src
                   usr/libdata
                   usr/lib32"

    echo ""
    echo "Creating basejail ZFS datasets... please wait."

    for fs in $(echo $fs_list) ; do
        zfs create -o compression=lz4 -p $pool/iocage/base/${release}/root/$fs
    done
}

__reclone_basejail () {
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"
    local jail_release="$(__get_jail_prop release $fulluuid)"

    zfs destroy -rRf $pool/iocage/base@$fulluuid
    zfs snapshot -r  $pool/iocage/base@$fulluuid

    echo "* $fulluuid is a basejail, re-cloning jail.."

    # Re-clone required filesystems
    for fs in $bfs_list ; do
        # echo "  re-cloning: $pool/iocage/jails/$fulluuid/root/$fs"
        zfs clone $pool/iocage/base/$jail_release/root/$fs@$fulluuid \
                  $pool/iocage/jails/$fulluuid/root/$fs
    done
}

# Fetch release and prepare base ZFS filesystems-----------
__fetch_release () {
    local exist=$(zfs list | grep -w ^$pool/iocage)
    __print_release
    echo -n "Please select a release [$release]: "
    read answer
    if [ ! -z "$answer" ] ; then
        release="$answer"
    else
        answer="$release"
    fi

    for rel in $(echo $supported) ; do
        if [ "$answer" == "$rel" ] ; then
            release="$rel"
            match="1"
            break
        fi
    done

    if [ -z $match ] ; then
        echo "Invalid release $release specified, exiting.."
        exit 1
    fi

    local exist=$(zfs list | grep -w ^$pool/iocage)
    local download_exist=$(zfs list | grep -w ^$pool/iocage/download/$release)
    local rel_exist=$(zfs list | grep -w ^$pool/iocage/releases/$release)

    if [ -z "$exist" ] ; then
        zfs create -o compression=lz4 $pool/iocage
        zfs set mountpoint=$iocroot $pool/iocage
        zfs create -o compression=lz4 $pool/iocage/jails
        zfs mount -a
    fi

    if [ -z "$download_exist" ] ; then
        zfs create -o compression=lz4 -p $pool/iocage/download/$release
    fi

    ftpdir="/pub/FreeBSD/releases/amd64/$release"

    cd $iocroot/download/$release
    for file in $ftpfiles ; do
        if [ ! -e "$file" ] ; then
            fetch http://$ftphost$ftpdir/$file
        fi
    done

    if [ -z "$rel_exist" ] ; then
        zfs create -o compression=lz4 -p $pool/iocage/releases/$release/root
    fi

    for file in $(echo $ftpfiles) ; do
        if [ -e "$file" ] ; then
            echo "Extracting: $file"
            chflags -R noschg $iocroot/releases/$release/root
            tar -C $iocroot/releases/$release/root -xf $file
        fi
    done

        echo "* Updating base jail.."
        sleep 2

        env UNAME_r="$release" /usr/sbin/freebsd-update \
            -b $iocroot/releases/$release/root \
            -d $iocroot/releases/$release/root/var/db/freebsd-update/ fetch
        env UNAME_r="$release" /usr/sbin/freebsd-update \
            -b $iocroot/releases/$release/root \
            -d $iocroot/releases/$release/root/var/db/freebsd-update/ install

    if [ ! -d $iocroot/log ] ; then
        mkdir $iocroot/log
    fi

    __create_basejail $release
    chflags -R noschg $iocroot/base/$release/root
    tar --exclude \.zfs --exclude usr/sbin/chown -C $iocroot/releases/$release/root -cf - . | \
    tar --exclude \.zfs --exclude usr/sbin/chown -C $iocroot/base/$release/root -xf -

    if [ ! -e "$iocroot/base/$release/root/usr/sbin/chown" ] ; then
       cd $iocroot/base/$release/root/usr/sbin && ln -s ../bin/chgrp chown
    fi

    etcupdate extract -D $iocroot/base/$release/root \
    -s $iocroot/base/$release/root/usr/src
}

# This creates jails----------------------------------------------------
__create_jail () {
    local installed=$(zfs list -r $pool/iocage/releases|grep $release)

    if [ -z "$installed" ] ; then
        echo "Release $release not found locally, run fetch first"
        exit 1
    fi

    if [ "${2}" = "-c" ] ; then
        fs_list=$(zfs list -rH -o name $pool/iocage/releases/$release)

        zfs snapshot -r $pool/iocage/releases/$release@$uuid
        for fs in $fs_list ; do
            cfs=$(echo $fs | sed s#/releases/$release#/jails/$uuid#g)
            #echo "cloning $fs into $cfs"
            zfs clone $fs@$uuid $cfs
        done
    elif [ "${2}" = "-e" ] ; then
        zfs create -o compression=lz4 -p $pool/iocage/jails/$uuid/root
    elif [ "${2}" = "-b" ] ; then
       export type=basejail
       zfs snapshot -r $pool/iocage/base@$uuid
       zfs create -o compression=lz4 -p $pool/iocage/jails/$uuid/root/usr

       for fs in $bfs_list ; do
           zfs clone -o compression=lz4 -o readonly=on \
           $pool/iocage/base/${release}/root/$fs@$uuid \
           $pool/iocage/jails/$uuid/root/$fs
       done

       for dir in $bdir_list ; do
           cp -a $iocroot/base/${release}/root/$dir \
                 $iocroot/jails/$uuid/root/$dir
       done

    else
        zfs snapshot -r $pool/iocage/releases/$release@$uuid
        zfs send     -R $pool/iocage/releases/$release@$uuid | \
        zfs recv        $pool/iocage/jails/$uuid
        zfs destroy  -r $pool/iocage/releases/$release@$uuid
        zfs destroy  -r $pool/iocage/jails/$uuid@$uuid
    fi

    __configure_jail $pool/iocage/jails/$uuid
    touch $iocroot/jails/$uuid/fstab

    # at create time set the default rc.conf
    if [ "${2}" != "-e" ] ; then
        echo "hostname=\"${hostname}\"" > $iocroot/jails/${uuid}/root/etc/rc.conf
        __jail_rc_conf >> \
        $iocroot/jails/${uuid}/root/etc/rc.conf
        __resolv_conf > $iocroot/jails/${uuid}/root/etc/resolv.conf
    elif [ "${2}" = "-e" ] ; then
        echo $uuid
    fi

    zfs create -o compression=lz4 ${pool}/$jail_zfs_dataset
    zfs set mountpoint=none ${pool}/$jail_zfs_dataset
    zfs set jailed=on ${pool}/$jail_zfs_dataset

    # Install extra packages
    # this requires working resolv.conf in jail
    if [ "$pkglist" != "none" ] ; then
        __pkg_install "$iocroot/jails/${uuid}/root"
    fi
}

# Cloning jails ----------------------------------------------------------
__clone_jail () {
    local name="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $1 }')"
    local snapshot="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $2 }')"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset="$(__find_jail $name)"

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fs_list="$(zfs list -rH -o name $dataset)"

    if [ -z "$snapshot" ] ; then
        zfs snapshot -r ${dataset}@${uuid}
        for fs in $fs_list ; do
            cfs="$(echo $fs | sed s#$dataset#$pool/iocage/jails/$uuid#g)"
            zfs clone $fs@$uuid $cfs
        done
    else
        for fs in $fs_list ; do
            cfs="$(echo $fs | sed s#$dataset#$pool/iocage/jails/$uuid#g)"
            zfs clone $fs@$snapshot $cfs
        done
    fi

    __configure_jail $pool/iocage/jails/$uuid
    mv $iocroot/jails/$uuid/fstab $iocroot/jails/$uuid/fstab.$name
    touch $iocroot/jails/$uuid/fstab

    cat $iocroot/jails/${uuid}/root/etc/rc.conf | \
    sed -E "s/[a-zA-Z0-9]{8,}-.*-.*-.*-[a-zA-Z0-9]{12,}/$uuid/g" \
    > $iocroot/jails/${uuid}/rc.conf

    mv $iocroot/jails/${uuid}/rc.conf \
    $iocroot/jails/${uuid}/root/etc/rc.conf
}

# Destroy jails --------------------------------------------------------------
__destroy_jail () {
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset="$(__find_jail $name)"

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local origin="$(zfs get -H -o value origin $dataset)"
    local fulluuid="$(__check_name $name)"
    local jail_path="$(__get_jail_prop mountpoint $fulluuid)"
    local state="$(jls | grep ${jail_path} | wc -l)"
    local jail_type="$(__get_jail_prop type $fulluuid)"
    local jail_release="$(__get_jail_prop release $fulluuid)"

    echo " "
    echo "  WARNING: this will destroy jail $fulluuid"
    echo "  Dataset: $dataset"
    echo " "
    echo -n "  Are you sure ? Y[n]: "
    read answer

    if [ "$answer" == "Y" ]; then
        if [ "$state" -lt "1" ] ; then
            echo "  Destroying: $fulluuid"

            __unlink_tag $dataset

            zfs destroy -fr $dataset

            if [ "$origin" != "-" ] ; then
                echo "  Destroying clone origin: $origin"
                zfs destroy -r $origin
            fi

            if [ $jail_type == "basejail" ] ; then
                zfs destroy -fr $pool/iocage/base/$jail_release@$fulluuid
            fi

        elif [ "$state" -eq "1" ] ; then
            echo "  ERROR: Jail is up and running ..exiting"
            exit 1
        fi
   else
       echo "  Command not confirmed.  No action taken."
   fi

}

# Configure properties -------------------------------------------------
__configure_jail () {
    local CONF="$CONF_NET
                $CONF_JAIL
                $CONF_RCTL
                $CONF_CUSTOM
                $CONF_SYNC"

    echo "Configuring jail.."
    for prop in $CONF ; do
        prop_name=$prop
        eval prop="\$${prop}"
        if [ ! -z "$prop" ] ; then
            echo "** $prop_name=$prop"
            zfs set org.freebsd.iocage:$prop_name="$prop" $1
            if [ "$prop_name" == "tag" ] ; then
                __link_tag $1
            fi
        fi
    done

    for prop in $CONF_ZFS ; do
        prop_name=$prop
        eval prop="\$${prop}"
        if [ ! -z "$prop" ] && [ "$prop" != "readonly" ] ; then
            zfs set $prop_name="$prop" $1
        fi
    done
}

# Export every property specified on command line ----------------------
__export_props () {
    for i in "$@" ; do
        if [ "$(echo $i | grep -e ".*=.*")" ] ; then
            export "$i"
        fi
    done
}

# Set properties ------------------------------------------------------
__set_jail_prop () {
    local name="$2"
    local property="$1"

    if [ -z "$name" ] || [ -z "$property" ] ; then
        echo "  ERROR: missing property or UUID"
        exit 1
    fi

    local dataset="$(__find_jail $name)"

    if [ -z "$dataset" ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ "$dataset" == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local pname="$(echo $property|awk 'BEGIN { FS = "=" } ; { print $1 }')"
    local pval="$(echo $property|awk 'BEGIN { FS = "=" } ; { print $2 }')"

    if [ -z "$pname" ] || [ -z "$pval" ] ; then
        echo "  ERROR: set failed, incorrect property syntax!"
        exit 1
    fi

    local found="0"

    local CONF="$CONF_NET
                $CONF_JAIL
                $CONF_RCTL
                $CONF_CUSTOM
                $CONF_SYNC"

    for prop in $CONF ; do
        if [ "$prop" == "$pname" ] ; then
            found=1
            zfs set org.freebsd.iocage:${prop}="${pval}" $dataset
            if [ "$pname" == "tag" ] ; then
                __unlink_tag $dataset
                __link_tag $dataset
            fi
        fi
    done

    for prop in $CONF_ZFS ; do
        if [ "$prop" == "$pname" ] ; then
            zfs set $prop="$pval" $dataset
            found=1
        fi
    done

    if [ $found -ne "1" ] ; then
        echo "  ERROR: unsupported property: $pname !"
        exit 1
    fi
}

# Get properties -----------------------------------------------------
__get_jail_prop () {
    local name="$2"
    local property="$1"

    if [ -z "$property" ] ; then
        echo "  ERROR: get failed, incorrect property syntax!"
        exit 1
    fi

    if [ -z "$name" ] ; then
        echo "  ERROR: mising UUID!"
        exit 1
    fi

    local dataset="$(__find_jail $name)"

    if [ -z "$dataset" ] ; then
        echo "  ERROR: jail $name not found!"
        exit 1
    fi

    if [ "$dataset" == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local found="0"

    local CONF="$CONF_NET
                $CONF_JAIL
                $CONF_RCTL
                $CONF_CUSTOM
                $CONF_SYNC"

    for prop in $CONF ; do
        if [ $prop == $property ] ; then
            found=1
            local value="$(zfs get -H -o value org.freebsd.iocage:$prop \
                         $dataset)"
            echo "$value"
        elif [ $property == "all" ] ; then
            found=1
            local value="$(zfs get -H -o value org.freebsd.iocage:$prop \
                         $dataset)"
            echo "$prop:$value"
        fi
    done

    for prop in $CONF_ZFS ; do
        if [ $prop == $property ] ; then
            found=1
            local value="$(zfs get -H -o value $prop $dataset)"
            echo "$value"
        fi
    done

    if [ $found -ne "1" ] ; then
        echo "  ERROR: unsupported property: $property !"
        exit 1
    fi
}

__usage () {
    echo "usage:"
    echo "  iocage fetch [release=RELEASE | ftphost=ftp.hostname.org]"
    echo "  iocage create [-b|-c|-e] [release=RELEASE] [pkglist=file] [property=value]"
    echo "  iocage clone [UUID|TAG]@snapshot [property=value]"
    echo "  iocage destroy [UUID|TAG]"
    echo "  iocage list [-t]"
    echo "  iocage start [UUID|TAG]"
    echo "  iocage stop [UUID|TAG]"
    echo "  iocage restart [UUID|TAG]"
    echo "  iocage rcboot"
    echo "  iocage rcshutdown"
    echo "  iocage console [UUID|TAG]"
    echo "  iocage exec [-u username | -U username] [UUID|TAG] command [arg ...]"
    echo "  iocage chroot [UUID|TAG] [command]"
    echo "  iocage df"
    echo "  iocage show property"
    echo "  iocage get [property | all ] [UUID|TAG]"
    echo "  iocage set property=value [UUID|TAG]"
    echo "  iocage cap [UUID|TAG]"
    echo "  iocage limits [UUID|TAG]"
    echo "  iocage uncap [UUID|TAG]"
    echo "  iocage inuse [UUID|TAG]"
    echo "  iocage snapshot [UUID|TAG]@snapshotname"
    echo "  iocage snaplist [UUID|TAG]"
    echo "  iocage snapremove [UUID|TAG]@snapshotname"
    echo "  iocage rollback [UUID|TAG]@snapshotname"
    echo "  iocage promote [UUID|TAG]"
    echo "  iocage runtime [UUID|TAG]"
    echo "  iocage update [UUID|TAG]"
    echo "  iocage upgrade [UUID|TAG]"
    echo "  iocage record start|stop [UUID|TAG]"
    echo "  iocage package [UUID|TAG]"
    echo "  iocage export [UUID|TAG]"
    echo "  iocage import UUID [property=value]"
    echo "  iocage defaults"
    echo "  iocage version | --version"
    echo "  iocage help"
    echo " "
    echo "  Hint:  you can use shortened UUIDs!"
    echo " "
    echo "  e.g. for  adae47cb-01a8-11e4-aa78-3c970ea3222f"
    echo "       use  adae47cb or just adae"
}

__get_jail_name () {
    for i in $@; do
        :;
    done

    echo $i
}

# Find and return the jail's top level ZFS dataset
__find_jail () {
    local name=$1
    local jlist="/tmp/iocage-jail-list.$$"
    local jails="$(zfs list -rH -o name $pool/iocage/jails \
                 | grep -E \
                "^$pool/iocage/jails/[a-zA-Z0-9]{8,}-.*-.*-.*-[a-zA-Z0-9]{12,}$")"

    if [ "${name}" == "ALL" ] ; then
        for jail in $jails ; do
            echo $jail
        done
    else
        for jail in $jails ; do
            found="$(echo $jail |grep -iE "^$pool/iocage/jails/$name"|wc -l)"
            local tag="$(zfs get -H -o value org.freebsd.iocage:tag $jail)"

            if [ "$found" -eq 1 ] ; then
                echo $jail >> $jlist
            fi

            if [ $tag == $name ] ; then
                echo $jail >> $jlist
            fi
        done

        if [ ! -e $jlist ] ; then
            exit 0
        fi

        if [ "$(cat $jlist|wc -l)" -eq "1" ] ; then
            cat $jlist
        elif [ "$(cat $jlist|wc -l)" -gt "1" ] ; then
            echo "multiple"
        fi
    fi

    rm  -f $jlist
}

__start_jail () {
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset="$(__find_jail $name)"

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"
    local jail_type="$(__get_jail_prop type $fulluuid)"
    local tag="$(__get_jail_prop tag $fulluuid)"
    local jail_hostid="$(__get_jail_prop hostid $fulluuid)"
    local jail_path="$(__get_jail_prop mountpoint $fulluuid)"
    local template="$(__get_jail_prop template $fulluuid)"
    local cpuset="$(__get_jail_prop cpuset $fulluuid)"
    local procfs="$(__get_jail_prop mount_procfs $fulluuid)"
    local jail_path="$(__get_jail_prop mountpoint $fulluuid)"
    local state="$(jls | grep ${jail_path} | wc -l)"
    local vnet="$(__get_jail_prop vnet $fulluuid)"
    local nics="$(__get_jail_prop interfaces $fulluuid \
               |awk 'BEGIN { FS = "," } ; { print $1,$2,$3,$4 }')"

    if [ "$state" -eq "1" ] ; then
        echo "* ${fulluuid}: is already up"
        exit 1
    fi

    if [ $jail_type == "basejail" ] ; then
        # Re-clone required filesystems
        __reclone_basejail $name
    fi

    for i in $nics ; do
        local nic="$(echo $i | awk 'BEGIN { FS = ":" } ; { print $1 }')"
        local bridge="$(echo $i | awk 'BEGIN { FS = ":" } ; { print $2 }')"

        if [ -z $nic ] || [ -z $bridge ] ; then
            echo "  ERROR  : incorrect interfaces property format"
            echo "  HINT   : check with \"iocage get interfaces $fulluuid\""
            echo "  Example: vnet0:bridge0"
            exit 1
        fi
    done

    if [ $template == "yes" ] ; then
        return
    fi

    if [ "$jail_hostid" != "$hostid" ] ; then
        echo "ERROR: hostid mismatch, start failed!"
        echo "    jail hostid: $jail_hostid"
        echo "  host's hostid: $hostid"
        exit 1
    fi

    if [ "$procfs" == "1" ] ; then
        mount -t procfs proc $iocroot/jails/${fulluuid}/root/proc
    fi

    local jzfs="$(__get_jail_prop jail_zfs $fulluuid)"
    local jzfs_dataset="$(__get_jail_prop jail_zfs_dataset $fulluuid)"

    if [ $jzfs == "on" ] ; then
        __set_jail_prop allow_mount=1 $fulluuid
        __set_jail_prop enforce_statfs=1 $fulluuid
        __set_jail_prop allow_mount_zfs=1 $fulluuid
        zfs set jailed=on ${pool}/$jzfs_dataset
    fi

    if [ $vnet == "on" ] || [ $vnet == "-" ] ; then
        if [ ! -z $(sysctl -qn kern.features.vimage) ] ; then
            echo "* Starting $fulluuid ($tag)"
            __vnet_start $fulluuid

            if [ $? -eq 1 ] ; then
                echo "  ! Start                FAILED"
                exit 1
            else
                echo "  + Started                  OK"
            fi

            echo -n "  + Configuring VNET"
            __networking start $fulluuid

            if [ $? -eq 1 ] ; then
                echo "         FAILED"
            else
                echo "         OK"
            fi
        else
            echo "  ERR: start failed for $fulluuid"
            echo "  vnet=on but kernel is not VNET capable!"
            echo "  Turn vnet off for this jail or recompile kernel with VNET."
            exit 1
        fi
    else
        echo "* Starting $fulluuid ($tag)"
        __legacy_start $fulluuid
        if [ $? -eq 1 ] ; then
            echo "  ! Start                FAILED"
        else
            echo "  + Started (shared IP mode) OK"
        fi
    fi

    cd ${jail_path}/root/dev && ln -s ../var/run/log log

    __rctl_limits $fulluuid

    if [ $cpuset != "off" ] ; then
        echo -n "  + Appliyng CPU affinity"
        local jid="$(jls -j ioc-${fulluuid} jid)"
        cpuset -l $cpuset -j $jid
        if [ $? -eq 1 ] ; then
            echo "    FAILED"
        else
            echo "    OK"
        fi
    fi

    echo -n "  + Starting services"
    jexec ioc-${fulluuid} $(__get_jail_prop exec_start $fulluuid) \
     >> $iocroot/log/${fulluuid}-console.log 2>&1

    if [ $? -eq 1 ] ; then
        echo "        FAILED"
    else
        echo "        OK"
    fi

    if [ $jzfs == "on" ] ; then
        zfs jail ioc-${fulluuid} ${pool}/$jzfs_dataset
    fi

    zfs set org.freebsd.iocage:last_started=$(date "+%F_%T") $dataset

}

# Start a VNET jail
__vnet_start () {
    local name="$1"
    local jail_path="$(__get_jail_prop mountpoint $name)"
    local fdescfs="mount.fdescfs=$(__get_jail_prop mount_fdescfs $name)"
    local tmpfs="allow.mount.tmpfs=$(__get_jail_prop allow_mount_tmpfs $name)"

    if [ "$(uname -U)" == "903000" ];
    then
      fdescfs=""
      tmpfs=""
    fi

    jail -c vnet \
    name="ioc-$(__get_jail_prop host_hostuuid $name)" \
    host.hostname="$(__get_jail_prop hostname $name)" \
    path="${jail_path}/root" \
    securelevel="$(__get_jail_prop securelevel $name)" \
    host.hostuuid="$(__get_jail_prop host_hostuuid $name)" \
    devfs_ruleset="$(__get_jail_prop devfs_ruleset $name)" \
    enforce_statfs="$(__get_jail_prop enforce_statfs $name)" \
    children.max="$(__get_jail_prop children_max $name)" \
    allow.set_hostname="$(__get_jail_prop allow_set_hostname $name)" \
    allow.sysvipc="$(__get_jail_prop allow_sysvipc $name)" \
    allow.raw_sockets="$(__get_jail_prop allow_raw_sockets $name)" \
    allow.chflags="$(__get_jail_prop allow_chflags $name)" \
    allow.mount="$(__get_jail_prop allow_mount $name)" \
    allow.mount.devfs="$(__get_jail_prop allow_mount_devfs $name)" \
    allow.mount.nullfs="$(__get_jail_prop allow_mount_nullfs $name)" \
    allow.mount.procfs="$(__get_jail_prop allow_mount_procfs $name)" \
    ${tmpfs} \
    allow.mount.zfs="$(__get_jail_prop allow_mount_zfs $name)" \
    allow.quotas="$(__get_jail_prop allow_quotas $name)" \
    allow.socket_af="$(__get_jail_prop allow_socket_af $name)" \
    exec.prestart="$(__findscript $name prestart)" \
    exec.poststart="$(__findscript $name poststart)" \
    exec.prestop="$(__findscript $name prestop)" \
    exec.stop="$(__get_jail_prop exec_stop $name)" \
    exec.clean="$(__get_jail_prop exec_clean $name)" \
    exec.timeout="$(__get_jail_prop exec_timeout $name)" \
    stop.timeout="$(__get_jail_prop stop_timeout $name)" \
    mount.fstab="${jail_path}/fstab" \
    mount.devfs="$(__get_jail_prop mount_devfs $name)" \
    ${fdescfs} \
    allow.dying \
    exec.consolelog="$iocroot/log/${name}-console.log" \
    persist
}

# Start a shared IP jail
__legacy_start () {
    local name="$1"
    local jail_path="$(__get_jail_prop mountpoint $name)"
    local ip4_addr="$(__get_jail_prop ip4_addr $name)"
    local ip6_addr="$(__get_jail_prop ip6_addr $name)"

    local fdescfs="mount.fdescfs=$(__get_jail_prop mount_fdescfs $name)"
    local tmpfs="allow.mount.tmpfs=$(__get_jail_prop allow_mount_tmpfs $name)"

    if [ "$(uname -U)" == "903000" ];
    then
      fdescfs=""
      tmpfs=""
    fi


    if [ $ip4_addr == "none" ] ; then
        ip4_addr=""
    fi

    if [ $ip6_addr == "none" ] ; then
        ip6_addr=""
    fi

    if [ $ipv6 == "on" ] ; then
        jail -c \
        ip4.addr="$ip4_addr" \
        ip4.saddrsel="$(__get_jail_prop ip4_saddrsel $name)" \
        ip4="$(__get_jail_prop ip4 $name)" \
        ip6.addr="$ip6_addr" \
        ip6.saddrsel="$(__get_jail_prop ip6_saddrsel $name)" \
        ip6="$(__get_jail_prop ip6 $name)" \
        name="ioc-$(__get_jail_prop host_hostuuid $name)" \
        host.hostname="$(__get_jail_prop hostname $name)" \
        path="${jail_path}/root" \
        securelevel="$(__get_jail_prop securelevel $name)" \
        host.hostuuid="$(__get_jail_prop host_hostuuid $name)" \
        devfs_ruleset="$(__get_jail_prop devfs_ruleset $name)" \
        enforce_statfs="$(__get_jail_prop enforce_statfs $name)" \
        children.max="$(__get_jail_prop children_max $name)" \
        allow.set_hostname="$(__get_jail_prop allow_set_hostname $name)" \
        allow.sysvipc="$(__get_jail_prop allow_sysvipc $name)" \
        allow.raw_sockets="$(__get_jail_prop allow_raw_sockets $name)" \
        allow.chflags="$(__get_jail_prop allow_chflags $name)" \
        allow.mount="$(__get_jail_prop allow_mount $name)" \
        allow.mount.devfs="$(__get_jail_prop allow_mount_devfs $name)" \
        allow.mount.nullfs="$(__get_jail_prop allow_mount_nullfs $name)" \
        allow.mount.procfs="$(__get_jail_prop allow_mount_procfs $name)" \
	${tmpfs} \
        allow.mount.zfs="$(__get_jail_prop allow_mount_zfs $name)" \
        allow.quotas="$(__get_jail_prop allow_quotas $name)" \
        allow.socket_af="$(__get_jail_prop allow_socket_af $name)" \
        exec.prestart="$(__findscript $name prestart)" \
        exec.poststart="$(__findscript $name poststart)" \
        exec.prestop="$(__findscript $name prestop)" \
        exec.stop="$(__get_jail_prop exec_stop $name)" \
        exec.clean="$(__get_jail_prop exec_clean $name)" \
        exec.timeout="$(__get_jail_prop exec_timeout $name)" \
        stop.timeout="$(__get_jail_prop stop_timeout $name)" \
        mount.fstab="${jail_path}/fstab" \
        mount.devfs="$(__get_jail_prop mount_devfs $name)" \
	${fdescfs} \
        allow.dying \
        exec.consolelog="$iocroot/log/${name}-console.log" \
        persist
    else
        jail -c \
        ip4.addr="$ip4_addr" \
        ip4.saddrsel="$(__get_jail_prop ip4_saddrsel $name)" \
        ip4="$(__get_jail_prop ip4 $name)" \
        name="ioc-$(__get_jail_prop host_hostuuid $name)" \
        host.hostname="$(__get_jail_prop hostname $name)" \
        path="${jail_path}/root" \
        securelevel="$(__get_jail_prop securelevel $name)" \
        host.hostuuid="$(__get_jail_prop host_hostuuid $name)" \
        devfs_ruleset="$(__get_jail_prop devfs_ruleset $name)" \
        enforce_statfs="$(__get_jail_prop enforce_statfs $name)" \
        children.max="$(__get_jail_prop children_max $name)" \
        allow.set_hostname="$(__get_jail_prop allow_set_hostname $name)" \
        allow.sysvipc="$(__get_jail_prop allow_sysvipc $name)" \
        allow.raw_sockets="$(__get_jail_prop allow_raw_sockets $name)" \
        allow.chflags="$(__get_jail_prop allow_chflags $name)" \
        allow.mount="$(__get_jail_prop allow_mount $name)" \
        allow.mount.devfs="$(__get_jail_prop allow_mount_devfs $name)" \
        allow.mount.nullfs="$(__get_jail_prop allow_mount_nullfs $name)" \
        allow.mount.procfs="$(__get_jail_prop allow_mount_procfs $name)" \
	${tmpfs} \
        allow.mount.zfs="$(__get_jail_prop allow_mount_zfs $name)" \
        allow.quotas="$(__get_jail_prop allow_quotas $name)" \
        allow.socket_af="$(__get_jail_prop allow_socket_af $name)" \
        exec.prestart="$(__findscript $name prestart)" \
        exec.poststart="$(__findscript $name poststart)" \
        exec.prestop="$(__findscript $name prestop)" \
        exec.stop="$(__get_jail_prop exec_stop $name)" \
        exec.clean="$(__get_jail_prop exec_clean $name)" \
        exec.timeout="$(__get_jail_prop exec_timeout $name)" \
        stop.timeout="$(__get_jail_prop stop_timeout $name)" \
        mount.fstab="${jail_path}/fstab" \
        mount.devfs="$(__get_jail_prop mount_devfs $name)" \
	${fdescfs} \
        allow.dying \
        exec.consolelog="$iocroot/log/${name}-console.log" \
        persist
    fi
}

__stop_jail () {
    local name="$1"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"
    local jail_path="$(__get_jail_prop mountpoint $name)"
    local tag="$(__get_jail_prop tag $fulluuid)"
    local exec_prestop="$(__findscript $fulluuid prestop)"
    local exec_stop="$(__get_jail_prop exec_stop $fulluuid)"
    local exec_poststop="$(__findscript $fulluuid poststop)"
    local vnet="$(__get_jail_prop vnet $fulluuid)"
    local state="$(jls | grep ${jail_path} | wc -l)"

    if [  "$state" -lt "1" ] ; then
        echo "* ${fulluuid}: is already down"
        exit 1
    fi

    echo "* Stopping $fulluuid ($tag)"

    echo -n "  + Running pre-stop"
    echo "$exec_prestop" | sh
    if [ $? -ne 1 ] ; then
        echo "         OK"
    else
        echo "     FAILED"
    fi

    echo -n "  + Stopping services"

    jexec ioc-${fulluuid} $exec_stop >> $iocroot/log/${fulluuid}-console.log 2>&1

    if [ $? -ne 1 ] ; then
        echo "        OK"
    else
        echo "    FAILED"
    fi

    if [ $vnet == "on" ] ; then
        echo -n "  + Tearing down VNET"
        __networking stop $fulluuid
        if [ $? -eq 1 ] ; then
            echo "        FAILED"
        else
            echo "        OK"
        fi
    else
        __stop_legacy_networking $name
    fi

    echo -n "  + Removing jail process"
    jail -r ioc-${fulluuid}

    if [ $? -ne 1 ] ; then
        echo "    OK"
    else
        echo "FAILED"
    fi

    echo -n "  + Running post-stop"
    echo "$exec_poststop" | sh
    if [ $? -ne 1 ] ; then
        echo "        OK"
    else
        echo "    FAILED"
    fi

    umount -afvF ${jail_path}/fstab > /dev/null 2>&1
    umount ${jail_path}/root/dev/fd > /dev/null 2>&1
    umount ${jail_path}/root/dev    > /dev/null 2>&1
    umount ${jail_path}/root/proc   > /dev/null 2>&1

    if [ -d $iocroot/jails/${fulluuid}/recorded ] ; then
        umount -ft unionfs $iocroot/jails/${fulluuid}/root > /dev/null 2>&1
    fi

    if [ ! -z $(sysctl -qn kern.features.rctl) ] ; then
        local rlimits="$(rctl | grep $fulluuid| wc -l)"
        if [ $rlimits -gt "0" ] ; then
            rctl -r jail:ioc-${fulluuid}
        fi
    fi
}

# Soft restart
__restart_jail () {
    local name="$1"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset="$(__find_jail $name)"

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"
    local exec_stop="$(__get_jail_prop exec_stop $fulluuid)"
    local exec_start="$(__get_jail_prop exec_start $fulluuid)"
    local jid="$(jls -j ioc-${fulluuid} jid)"
    local tag="$(__get_jail_prop tag $fulluuid)"

    echo "* Soft restarting $fulluuid ($tag)"
    jexec ioc-${fulluuid} $exec_stop >> $iocroot/log/${fulluuid}-console.log 2>&1

    if [ $? -ne "1" ] ; then
        pkill -j $jid
        jexec ioc-${fulluuid} $exec_start >> $iocroot/log/${fulluuid}-console.log 2>&1
        zfs set org.freebsd.iocage:last_started=$(date "+%F_%T") $dataset
    else
        echo "  ERROR: soft restart failed.."
        exit 1
    fi
}

__rc_jails () {
    local action=$1
    local jails=$(__find_jail ALL)
    local boot_list="/tmp/iocage.$$"

    for jail in $jails ; do
        local name="$(zfs get -H -o value org.freebsd.iocage:host_hostuuid \
                    $jail)"
        local boot="$(zfs get -H -o value org.freebsd.iocage:boot $jail)"
        local priority="$(zfs get -H -o value org.freebsd.iocage:priority \
                        $jail)"

        if [ "$boot" == "on" ] ; then
            echo "${priority},${name}" >> $boot_list
        fi
    done

    if [ -e $boot_list ] ; then
        local boot_order=$(sort -n $boot_list)
        local shutdown_order=$(sort -rn $boot_list)
    else
        echo "  ERROR: None of the jails have boot on"
        exit 1
    fi

    if [ "$action" == "boot" ] ; then
        echo "* [I|O|C] booting jails... "

        for i in $boot_order ; do
            local jail="$(echo $i | cut -f2 -d,)"
            local jail_path="$(__get_jail_prop mountpoint $jail)"
            local state="$(jls | grep ${jail_path} | wc -l)"

            if [ "$state" -lt "1" ] ; then
                __start_jail $jail
            fi
        done

    elif [ "$action" == "shutdown" ] ; then
        echo "* [I|O|C] shutting down jails... "

        for i in $shutdown_order ; do
            local jail="$(echo $i | cut -f2 -d,)"
            local jail_path="$(__get_jail_prop mountpoint $jail)"
            local state="$(jls | grep ${jail_path} | wc -l)"

            if [ "$state" -eq "1" ] ; then
                __stop_jail $jail
            fi
        done

    fi

    rm $boot_list
}

__list_jails () {
    local jails=$(__find_jail ALL)
    local switch=$1
    local all_jids=$(jls -N -h jid | grep -v -x jid )
    local ioc_jids=""
    local non_ioc_jids=""

    if [ ! -z ${switch} ] && [ $switch == "-r" ] ; then
        echo "Downloaded releases:"
        local releases="$(zfs list -o name -Hr $pool/iocage/releases \
                        | grep RELEASE$ | cut -d \/ -f 4)"
        for rel in $(echo $releases) ; do
            printf "%15s\n" "$rel"
        done
        exit 0
    fi

    printf "%-4s  %-36s  %s  %s  %s\n" "JID" "UUID"  "BOOT"\
           "STATE" "TAG"
    for jail in $jails ; do
        uuid=$(zfs get -H -o value org.freebsd.iocage:host_hostuuid $jail)
        boot=$(zfs get -H -o value org.freebsd.iocage:boot $jail)
        tag=$(zfs get -H -o value org.freebsd.iocage:tag $jail)
        jail_path=$(zfs get -H -o value mountpoint $jail)
        state=$(jls | grep ${jail_path} | awk '{print$1}')
        template=$(zfs get -H -o value org.freebsd.iocage:template $jail)
        # get jid for iocage jails
        jid=$(jls -j "ioc-"$uuid  -h jid 2> /dev/null | grep -v -x "jid")
        if [ -z "$jid"  ] ; then
            jid="-"
        fi
        local ioc_jids=$ioc_jids" "$jid

        if [ -z "$state" ] ; then
            state=down
        else
            state=up
        fi

        if [ -z ${switch} ] ; then
            switch=zero
        fi

        if [ $switch == "-t" ] ; then
            if [ $template == "yes" ] ; then
                printf "%-4s  %-+.36s  %-3s   %-4s   %s\n" "$jid" "$uuid" \
                "$boot" "$state" "$tag"
            fi
        elif [ $switch != "-t" ] ; then
            if [ $template != "yes" ] ; then
                printf "%-4s  %-+.36s  %-4s  %-4s   %s\n" "$jid" "$uuid"  \
                "$boot" "$state" "$tag"
            fi
        fi
    done

    # create list of active jids not registered in iocage
    for all_jail in $all_jids ; do
        for ioc_jail in $ioc_jids ; do
            if [ "$all_jail" == "$ioc_jail" ] ; then
                local temp_loop_var=""
                break
            else
                local temp_loop_var=$all_jail

            fi
        done
    if [ -n "$temp_loop_var" ] ; then
        local non_ioc_jids=$non_ioc_jids" "$temp_loop_var
    fi
    done

    # output non iocage jails currently active
    if [ -n "$non_ioc_jids" ] ; then
        if [ $switch != "-t" ] ; then
            printf "%-+40s\n" "--- non iocage jails currently active ---"
            printf "%-4s  %-36s  %-15s  %s \n" "JID" "PATH"\
                  "IP4" "HOSTNAME"
            for jid in $non_ioc_jids ; do
                path=$(jls -j $jid  -h path | grep -v -x "path")
                ip4=$(jls -j $jid  -h ip4.addr | grep -v -x "ip4.addr")
                host_hostname=$(jls -j $jid  -h host.hostname | grep -v -x "host.hostname")
                printf "%-4s  %-36.36s  %-15s  %s\n" "$jid" "$path"  \
                        "$ip4" "$host_hostname"
            done
        fi
    fi
}

__show () {
    local jails=$(__find_jail ALL)
    local prop="$1"

    printf "%-36s  %s\n" "UUID" "$prop"

    for jail in $jails ; do
        local name="$(zfs get -H -o value org.freebsd.iocage:host_hostuuid \
                    $jail)"
        local value="$(__get_jail_prop $prop $name)"

        printf "%-+.36s  %s\n" "$name"  "$value"
    done
}

__print_disk () {
    local jails=$(__find_jail ALL)

    printf "%-36s  %-6s  %-5s  %-5s  %-5s  %-5s\n" "UUID" "CRT" "RES" "QTA" "USE" "AVA"

    for jail in $jails ; do
        uuid=$(zfs get -H -o value org.freebsd.iocage:host_hostuuid $jail)
        crt=$(zfs get -H -o value compressratio $jail)
        res=$(zfs get -H -o value reservation $jail)
        qta=$(zfs get -H -o value quota $jail)
        use=$(zfs get -H -o value used $jail)
        ava=$(zfs get -H -o value available $jail)

        printf "%-36s  %-6s  %-5s  %-5s  %-5s  %-5s\n" "$uuid" "$crt" "$res" "$qta" \
               "$use" "$ava"
    done
}

__find_mypool () {
    pools="$(zpool list -H -o name)"
    found="0"

    for i in $pools ; do
        mypool="$(zpool get comment $i | grep -v NAME | awk '{print $3}')"

        if [ "$mypool" == "iocage" ] ; then
            export pool=$i
            found=1
            break
        fi
    done

    if [ $found -ne 1 ] ; then
        if [ -n "$RC_PID" ]; then
            # RC_PID set means we are running from rc
            echo "ERROR: No pool for iocage jails found on boot ..exiting"
            exit 1
        else
            echo -n "  please select a pool for iocage jails [$i]: "
            read answer

            if [ -z "$answer" ] ; then
                answer=$i
            fi

            zpool set comment=iocage $answer
            export pool=$answer
        fi
    fi
}

__networking () {
    action="$1"
    local name="$2"
    local jid="$(jls -j ioc-$name jid)"
    local ip4="$(__get_jail_prop ip4_addr $name)"
    local ip6="$(__get_jail_prop ip6_addr $name)"
    local defaultgw="$(__get_jail_prop defaultrouter $name)"
    local defaultgw6="$(__get_jail_prop defaultrouter6 $name)"
    local nics="$(__get_jail_prop interfaces $name \
               |awk 'BEGIN { FS = "," } ; { print $1,$2,$3,$4 }')"
    local ip4_list="$(echo $ip4 | sed 's/,/ /g')"
    local ip6_list="$(echo $ip6 | sed 's/,/ /g')"

    if [ $action == "start" ] ; then
        for i in $nics ; do
            local nic=$(echo $i | awk 'BEGIN { FS = ":" } ; { print $1 }')
            local bridge=$(echo $i | awk 'BEGIN { FS = ":" } ; { print $2 }')
	    local memberif=$(ifconfig $bridge | grep member | head -n1 | cut -d' ' -f2)
	    local brmtu=$(ifconfig $memberif | head -n1 |cut -d' ' -f6)
            epair_a=$(ifconfig epair create)
            epair_b=$(echo $epair_a | sed s/a\$/b/)
            ifconfig ${epair_a} name ${nic}:${jid} mtu $brmtu
            ifconfig ${nic}:${jid} description "associated with jail: $name"
            ifconfig $epair_b vnet ioc-${2}
            jexec ioc-${2} ifconfig $epair_b name $nic mtu $brmtu
            ifconfig $bridge addm ${nic}:${jid} up
            ifconfig ${nic}:${jid} up
        done

        if [ "$ip4" != "none" ] ; then
            for i in $ip4_list ; do
                iface="$(echo $i |awk 'BEGIN { FS = "|" } ; { print $1 }')"
                ip="$(echo $i |awk 'BEGIN { FS = "|" } ; { print $2 }')"
                jexec ioc-${2} ifconfig $iface $ip up
            done
        fi

        if [ "$ip6" != "none" ] ; then
            for i in $ip6_list ; do
                iface="$(echo $i |awk 'BEGIN { FS = "|" } ; { print $1 }')"
                ip="$(echo $i |awk 'BEGIN { FS = "|" } ; { print $2 }')"
                jexec ioc-${2} ifconfig $iface inet6 $ip up
            done
        fi

        if [ "$defaultgw" != "none" ] ; then
            jexec ioc-${2} route add default $defaultgw > /dev/null
        fi

	if [ "$defaultgw6" != "none" ] ; then
	    jexec ioc-${2} route add -6 default $defaultgw6 >/dev/null
	fi

    elif [ $action == "stop" ] ; then
        for if in $nics ; do
            local nic=$(echo $if | cut -f 1 -d:)
            ifconfig ${nic}:${jid} destroy
        done
    fi
}

__stop_legacy_networking () {
    local name="$1"

    local ip4_addr="$(__get_jail_prop ip4_addr $name)"
    local ip6_addr="$(__get_jail_prop ip6_addr $name)"

    if [ $ip4_addr != "none" ] ; then
        IFS=','
        for ip in $ip4_addr ; do
            local iface="$(echo $ip | \
                         awk 'BEGIN { FS = "|" } ; { print $1 }')"
            local ip4="$(echo $ip | \
                       awk 'BEGIN { FS = "|" } ; { print $2 }' | \
                       awk 'BEGIN { FS = "/" } ; { print $1 }')"

            ifconfig $iface $ip4 -alias
        done
    fi

    if [ $ip6_addr != "none" ] ; then
        IFS=','
        for ip6 in $ip6_addr ; do
            local iface="$(echo $ip6 | \
                         awk 'BEGIN { FS = "|" } ; { print $1 }')"
            local ip6="$(echo $ip6 | \
                       awk 'BEGIN { FS = "|" } ; { print $2 }' | \
                       awk 'BEGIN { FS = "/" } ; { print $1 }')"
            ifconfig $iface inet6 $ip6 -alias
        done
    fi
}

__rctl_limits () {
    local name="$1"
    local failed=0

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    local rlimits="$(__get_jail_prop rlimits $fulluuid)"

    if [ $rlimits == "on" ] ; then
        echo -n "  + Applying resource limits"
        for prop in $CONF_RCTL ; do
            value="$(__get_jail_prop $prop $fulluuid)"
            limit=$(echo $value | awk 'BEGIN { FS = ":" } ; { print $1 }')
            action=$(echo $value | awk 'BEGIN { FS = ":" } ; { print $2 }')

            if [ $limit == "off" ] ; then
                continue
            else
                if [ -z "$limit" ] || [ -z "$action" ] ; then
                    echo -n "  ERROR: incorrect resource limit: $limit action: "
                    echo "$action for property: $prop"
                    echo "  HINT : check man page for syntax."
                else
                    rctl -a jail:ioc-${fulluuid}:${prop}:${action}=${limit}
                    if [ $? -eq 1 ] ; then
                        echo "    FAILED to apply ${prop}=${action}:${limit}"
                        failed=1
                    fi
                fi
            fi
        done
        if [ $failed -ne 1 ] ; then
            echo " OK"
        fi
    fi
}

__rctl_list () {
    local name="$1"

    if [ -z "$name" ] ; then
        echo "* All active limits:"
        rctl | grep jail
    else
        local fulluuid="$(__check_name $name)"
        local jid="$(jls -j ioc-${fulluuid} jid)"
        local limits="$(rctl -h | grep $fulluuid)"

        echo "* Active limits for jail: $fulluuid"

        for i in $limits ; do
            limit=$(echo $i | cut -f 3,4 -d:)
            echo "  - $limit"
        done

        if [ ! -z "$jid" ] ; then
            echo "* CPU set: $(cpuset -g -j $jid | cut -f2 -d:)"
        fi
    fi
}

__rctl_uncap () {
    local name="$1"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    echo "  Releasing resource limits.."
    rctl -r jail:ioc-${fulluuid}
    echo "  Listing active rules for jail:"
    rctl | grep $fulluuid
}


__rctl_used () {
    local name="$1"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    echo "Consumed resources:"
    echo "-------------------"
    rctl -hu jail:ioc-${fulluuid}
}


__console () {
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    local login_flags=$(zfs get -H -o value org.freebsd.iocage:login_flags \
                       $pool/iocage/jails/$fulluuid)

    jexec ioc-${fulluuid} login $login_flags
}


__exec () {
    local jexecopts=

    # check for -U or -u to pass to jexec
    while getopts u:U: opt "$@"; do
        case "$opt" in
            [uU]) jexecopts="$jexecopts -$opt $OPTARG";;
            ?)    echo "  ERROR: invalid exec option: $opt"
                  exit 1
                  ;;
        esac
    done
    shift $(expr $OPTIND - 1)

    local name=$1
    shift

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    jexec $jexecopts ioc-${fulluuid} "$@"
}


__chroot () {
    local name="$1"
    local command="$2"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    chroot $iocroot/jails/${fulluuid}/root $command
}


__snapshot () {
    local name="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $1 }')"
    local snapshot="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $2 }')"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local date=$(date "+%F_%T")

    if [ ! -z $snapshot ] ; then
        zfs snapshot -r ${dataset}@${snapshot}
    else
        zfs snapshot -r ${dataset}@ioc-${date}
    fi
}


__snapremove () {
    local name="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $1 }')"
    local snapshot="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $2 }')"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: jail dataset not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    if [ ! -z $snapshot ] ; then
        echo "* removing snapshot: ${snapshot}"
        zfs destroy -r ${dataset}@${snapshot}
    else
        echo "  ERROR: snapshot not found"
        exit 1
    fi
}

__snaplist () {
    local name="$1"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"
    local snapshots="$(zfs list -Hrt snapshot -d1 $dataset | awk '{print $1}')"

    printf "%-36s  %-21s  %s   %s\n" "NAME" "CREATED"\
            "RSIZE" "USED"

    for i in $snapshots ; do
        local snapname=$(echo $i|cut -f 2 -d \@)
        local creation="$(zfs get -H -o value creation $i)"
        local used="$(zfs get -H -o value used $i)"
        local referenced="$(zfs get -H -o value referenced $i)"

        printf "%-36s  %-21s  %s    %s\n" "$snapname" "$creation"\
                   "$referenced" "$used"
    done

}

__rollback () {
    local name="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $1 }')"
    local snapshot="$(echo $1 |  awk 'BEGIN { FS = "@" } ; { print $2 }')"
    local dataset=$(__find_jail $name)

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fs_list=$(zfs list -rH -o name $dataset)

    if [ ! -z "$snapshot" ] ; then
        for fs in $fs_list ; do
            echo "* Rolling back to ${fs}@${snapshot}"
            zfs rollback -r ${fs}@${snapshot}
        done
    fi
}


__promote () {
    local name="$1"

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fs_list=$(zfs list -rH -o name $dataset)

    if [ -z $dataset ] ; then
        echo "  ERROR: dataset not found"
        exit 1
    fi

    for fs in $fs_list ; do
        local origin="$(zfs get -H -o value origin $fs)"

        if [ "$origin" != "-" ] ; then
            echo "* promoting filesystem: $fs"
            zfs promote $fs
            continue
        else
            echo "  INFO: filesystem $fs is not a clone"
        fi
    done
}

__runtime () {
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    local state="$(jls -n -j ioc-${fulluuid} | wc -l)"

    if [ "$state" -eq "1" ] ; then
        local params="$(jls -nj ioc-${fulluuid})"
        for i in $params ; do
            echo "  $i"
        done
    else
        echo " ERROR: jail $fulluuid is not up.."
    fi
}

__update () {
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    local mountpoint="$(__get_jail_prop mountpoint $fulluuid)"
    local date=$(date "+%F_%T")
    local jail_type="$(__get_jail_prop type $fulluuid)"
    local jail_release="$(__get_jail_prop release $fulluuid)"

    if [ $jail_type == "basejail" ] ; then
        # Re-clone required filesystems
        __reclone_basejail $name
    else
        echo "* creating back-out snapshot.."
        __snapshot ${fulluuid}@ioc-update_${date}

        echo "* Updating jail.."
        env UNAME_r="$release" /usr/sbin/freebsd-update \
            -b ${mountpoint}/root \
            -d ${mountpoint}/root/var/db/freebsd-update/ fetch
        env UNAME_r="$release" /usr/sbin/freebsd-update \
            -b ${mountpoint}/root \
            -d ${mountpoint}/root/var/db/freebsd-update/ install

        echo " "
        echo "* Once finished don't forget to remove the snapshot!"
    fi
}

__upgrade () {
    local name=$1
    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    if [ ! -d $iocroot/download/$release ] ; then
        echo "  ERROR: $release not found."
        echo "  Please run iocage fetch first."
	exit 1
    fi

    local fulluuid="$(__check_name $name)"
    local jail_type="$(__get_jail_prop type $fulluuid)"
    local jail_release="$(__get_jail_prop release $fulluuid)"
    local mountpoint="$(__get_jail_prop mountpoint $fulluuid)"
    local date=$(date "+%F_%T")
    local oldrelease="$(zfs get -H -o value org.freebsd.iocage:release $dataset)"

    if [ $jail_type == "basejail" ] ; then
        zfs set org.freebsd.iocage:release="$release" $dataset
        # Re-clone required filesystems
        __reclone_basejail $name
        cp -Rp ${mountpoint}/root/etc ${mountpoint}/root/etc.old
        etcupdate -D ${mountpoint}/root -F \
        -s $iocroot/base/$release/root/usr/src
        chroot ${mountpoint}/root /bin/sh -c "newaliases"

    if [ $? -eq 0 ] ; then
        echo ""
        echo "  Upgrade successful. Please restart jail and inspect. Remove ${mountpoint}/root/etc.old if everything is OK."
        exit 0
    else
        echo ""
        echo "  Mergemaster failed! Backing out."
	zfs set org.freebsd.iocage:release="$oldrelease" $dataset
	rm -rf ${mountpoint}/root/etc
	mv ${mountpoint}/root/etc.old ${mountpoint}/root/etc
        exit 1
      fi
    fi

    echo "* creating back-out snapshot.."
    __snapshot ${fulluuid}@ioc-upgrade_${date}

    echo "* Upgrading jail.."

    env UNAME_r=${oldrelease} /usr/sbin/freebsd-update \
    -b ${mountpoint}/root \
    -d ${mountpoint}/root/var/db/freebsd-update/ \
    -r $release upgrade

    if [ $? -eq 0 ] ; then
        while [ $? -eq 0 ] ; do
        env UNAME_r=${oldrelease} /usr/sbin/freebsd-update \
        -b ${mountpoint}/root \
        -d ${mountpoint}/root/var/db/freebsd-update/ \
        -r $release install
    done

    # Set jail's zfs property to new release
    zfs set org.freebsd.iocage:release="$release" $dataset
    else
       echo "  Upgrade failed, aborting install."
       exit 1
    fi

    echo " "
    echo "* Once finished don't forget to remove the snapshot!"
}

__record () {
    local name=$2
    local action=$1

    if [ -z $action ] ; then
        echo "  ERROR: missing action or UUID"
        exit 1
    fi

    if [ -z $name ] ; then
        echo "  ERROR: missing action or UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    local mountpoint="$(__get_jail_prop mountpoint $fulluuid)"
    local union_mount="$(mount -t unionfs | grep $fulluuid | wc -l)"

    if [ ! -d ${mountpoint}/recorded ] ; then
        mkdir ${mountpoint}/recorded
    fi


    if [ $action == "start" ] ; then
        echo "* Recording to: ${mountpoint}/recorded"

        if [ $union_mount -lt 1 ] ; then
            mount -t unionfs -o noatime,copymode=transparent \
            ${mountpoint}/recorded/ ${mountpoint}/root
        fi

    elif [ $action == "stop" ] ; then
        umount -ft unionfs $iocroot/jails/${fulluuid}/root > /dev/null 2>&1
        echo "* Stopped recording to: ${mountpoint}/recorded"

        find ${mountpoint}/recorded/ -type d -empty -exec rm -rf {} \; \
        > /dev/null 2>&1
        find ${mountpoint}/recorded/ -type f -size 0 -exec rm -f {} \; \
        > /dev/null 2>&1
        find ${mountpoint}/recorded/ -name "utx.*" -exec rm -f {} \; \
        > /dev/null 2>&1
        find ${mountpoint}/recorded/ -name .history -exec rm -f {} \; \
        > /dev/null 2>&1
    fi
}

__package () {
    # create package from recorded changes
    # sha256 too
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"

    local mountpoint="$(__get_jail_prop mountpoint $fulluuid)"

    if [ ! -d ${mountpoint}/recorded ] ; then
        echo "  ERROR: nothing to package, missing recorded directory!"
        echo "  HINT: have you recorded the jail?"
        exit 1
    fi

    if [ ! -d "$iocroot/packages" ] ; then
        mkdir $iocroot/packages
    fi

    echo "* Creating package..."
    tar -cvJf $iocroot/packages/$fulluuid.tar.xz -C ${mountpoint}/recorded . && \
    sha256 -q $iocroot/packages/$fulluuid.tar.xz > $iocroot/packages/$fulluuid.sha256
    echo "* Package saved to: $iocroot/packages/$fulluuid.tar.xz"
    echo "* Checksum created: $iocroot/packages/$fulluuid.sha256"
}

__import () {
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing package UUID"
        exit 1
    fi

    local package="$(find $iocroot/packages/ -name $name\*.tar.xz)"
    local image="$(find $iocroot/images/ -name $name\*.tar.xz)"
    local pcount="$(echo $package|wc -w)"
    local icount="$(echo $image|wc -w)"

    if [ $pcount -gt 1 ] ; then
        echo "  ERROR: multiple matching packages, please narrow down UUID."
        exit 1
    elif [ $pcount -eq 1 ] ; then
        local pcksum="$(find $iocroot/packages/ -name $name\*.sha256)"
    fi

    if [ $icount -gt 1 ] ; then
        echo "  ERROR: multiple matching images, please narrow down UUID."
        exit 1
    elif [ $icount -eq 1 ] ; then
        local icksum="$(find $iocroot/images/ -name $name\*.sha256)"
    fi

    if [ $pcount -gt 0 ] && [ $icount -gt 0 ] ; then
        echo "  ERROR: same UUID is matching both a package and an image."
        exit 1
    fi

    if [ $pcount -gt 0 ] ; then
        echo "* Found package $package"
        echo "* Importing package $package"

        if [ ! -f $pcksum ] ; then
            echo "  ERROR: missing checksum file!"
            exit 1
        fi

        local new_cksum="$(sha256 -q $package)"
        local old_cksum="$(cat $pcksum)"
        local uuid="$(__create_jail create | grep uuid | cut -f2 -d=)"
        local mountpoint="$(__get_jail_prop mountpoint $uuid)"

        if [ $new_cksum != $old_cksum ] ; then
            echo "  ERROR: checksum mismatch ..exiting"
            exit 1
        else
            tar -xvJf $package -C $mountpoint/root
        fi

    elif [ $icount -gt 0 ] ; then
        echo "* Found image $image"
        echo "* Importing image $image"

        if [ ! -f $icksum ] ; then
            echo "  ERROR: missing checksum file!"
            exit 1
        fi

        local new_cksum="$(sha256 -q $image)"
        local old_cksum="$(cat $icksum)"
        local uuid="$(__create_jail create -e|tail -1)"
        local mountpoint="$(__get_jail_prop mountpoint $uuid)"

        if [ $new_cksum != $old_cksum ] ; then
            echo "  ERROR: checksum mismatch ..exiting"
            exit 1
        else
            tar -xvJf $image -C $mountpoint/root
        fi

    else
        echo "  ERROR: package or image $name not found!"
        exit 1
    fi

    cat $iocroot/jails/${uuid}/root/etc/rc.conf | \
    sed -E "s/[a-zA-Z0-9]{8,}-.*-.*-.*-[a-zA-Z0-9]{12,}/$uuid/g" \
    > $iocroot/jails/${uuid}/rc.conf

    mv $iocroot/jails/${uuid}/rc.conf \
    $iocroot/jails/${uuid}/root/etc/rc.conf
}

__export () {
    # Export full jail
    # sha256
    local name=$1

    if [ -z $name ] ; then
        echo "  ERROR: missing UUID"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: $name not found"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local fulluuid="$(__check_name $name)"
    local jail_path="$(__get_jail_prop mountpoint $fulluuid)"
    local state=$(jls|grep ${jail_path} | wc -l)

    if [ "$state" -gt "0" ] ; then
        echo "  ERROR: $fulluuid is running!"
        echo "  Stop jail before exporting!"
        exit 1
    fi

    local mountpoint="$(__get_jail_prop mountpoint $fulluuid)"

    if [ ! -d "$iocroot/images" ] ; then
        mkdir $iocroot/images
    fi

    echo "* Exporting $fulluuid .."
    tar -cvJf $iocroot/images/$fulluuid.tar.xz -C ${mountpoint}/root . && \
    sha256 -q $iocroot/images/$fulluuid.tar.xz > $iocroot/images/$fulluuid.sha256
    echo "* Image saved to: $iocroot/images/$fulluuid.tar.xz"
    echo "* Checksum created: $iocroot/images/$fulluuid.sha256"

}

__check_name () {
    local name=$1

    if [ -z $name ] ; then
        echo "ERROR"
        exit 1
    fi

    local dataset=$(__find_jail $name)

    if [ -z $dataset ] ; then
        echo "  ERROR: jail $name not found!"
        exit 1
    fi

    if [ $dataset == "multiple" ] ; then
        echo "  ERROR: multiple matching UUIDs!"
        exit 1
    fi

    local uuid="$(__get_jail_prop host_hostuuid $name)"

    echo "$uuid"

}

# reads tag property from given jail dataset
# creates symlink from $iocroot/tags/<tag> to $iocroot/jails/<uuid>
__link_tag () {
    local dataset=$1
    local mountpoint
    local tag

    if mountpoint=$(zfs get -H -o value mountpoint $dataset) ; then
        if tag=$(zfs get -H -o value org.freebsd.iocage:tag $dataset); then
            mkdir -p $iocroot/tags
            if [ ! -e $iocroot/tags/$tag ] ; then
                ln -s $mountpoint $iocroot/tags/$tag
            else
                echo "  ERROR: tag already exists, can not symlink: $tag"
                exit 1
            fi
        fi
    else
        echo "  ERROR: no such dataset: $dataset"
        exit 1
    fi
}

# removes all symlinks found in $iocroot/tags pointing to the given jail dataset
__unlink_tag () {
    local dataset=$1
    local mountpoint

    if mountpoint=$(zfs get -H -o value mountpoint $dataset) ; then
        find $iocroot/tags -type l -lname "${mountpoint}*" -exec rm -f \{\} \;
    fi
}

__pkg_install () {
    local chrootdir="$1"

    if [ -e $pkglist ] ; then
        echo "* Installing extra packages.."
        for i in $(cat $pkglist) ; do
            pkg -c $chrootdir install -qy $i
        done
    fi
}

__jail_rc_conf () {
cat << EOT

cron_flags="$cron_flags -J 15"

# Disable Sendmail by default
sendmail_enable="NONE"
sendmail_submit_enable="NO"
sendmail_outbound_enable="NO"
sendmail_msp_queue_enable="NO"

# Run secure syslog
syslogd_flags="-c -ss"

# Enable IPv6
ipv6_activate_all_interfaces="YES"
EOT
}

# This is mostly for pkg autoinstall
__resolv_conf () {
    cat /etc/resolv.conf
}

# search for executable prestart|poststart|prestop|poststop in jail_dir first,
# else use jail exec_<type> property unchanged
__findscript () {
    local name=$1
    # type should be one of prestart|poststart|prestop|poststop
    local type=$2
    local jail_path="$(__get_jail_prop mountpoint $name)"

    if [ -x "${jail_path}/${type}" ]; then
        echo "${jail_path}/${type}"
    else
        echo "$(__get_jail_prop exec_${type} $name)"
    fi
}

__help () {
cat << 'EOT'
NAME
  iocage - jail manager amalgamating ZFS, VNET and resource limits
SYNOPSIS
  iocage fetch [release=RELEASE | ftphost=ftp.hostname.org]
  iocage create [-b|-c|-e] [release=RELEASE] [pkglist=file] [property=value]
  iocage clone UUID|TAG [UUID|TAG@snapshot] [property=value]
  iocage destroy UUID|TAG
  iocage list [-t|-r]
  iocage start UUID|TAG
  iocage stop UUID|TAG
  iocage restart UUID|TAG
  iocage rcboot
  iocage rcshutdown
  iocage console UUID|TAG
  iocage exec [-u username | -U username] UUID|TAG command [arg ...]
  iocage chroot UUID|TAG [command]
  iocage df
  iocage show property
  iocage get [property | all ] UUID|TAG
  iocage set property=value UUID|TAG
  iocage cap UUID|TAG
  iocage limits [UUID|TAG]
  iocage uncap UUID|TAG
  iocage inuse UUID|TAG
  iocage snapshot UUID|TAG [UUID|TAG@snapshotname]
  iocage snaplist UUID|TAG
  iocage snapremove UUID|TAG@snapshotname
  iocage rollback UUID|TAG@snapshotname
  iocage promote UUID|TAG
  iocage runtime UUID|TAG
  iocage update UUID|TAG
  iocage upgrade UUID|TAG [release=RELEASE]
  iocage record start|stop UUID|TAG
  iocage package UUID|TAG
  iocage export UUID|TAG
  iocage import UUID [property=value]
  iocage defaults
  iocage version | --version
  iocage help
DESCRIPTION
  iocage is a system administration tool for jails designed to simplify
  jail management tasks. It abstracts away the management of ZFS backed jails running VNET
  or shared IP networking with optional support for resource limits.

  Both, shared IP based jails and VNET enabled jails are supported.

  Each jail has a unique ID (UUID) automatically generated at creation time.
  Using the UUID as a jail identifier means that a jail can be replicated in a
  distributed environment with greater flexibility. This also eliminates
  potential naming clashes on large scale deployments and helps reduce
  operator error.

  Partial UUID calling is supported with every operation, e.g. for
  "adae47cb-01a8-11e4-aa78-3c970ea3222f" the use in the form of "adae47cb" or just "adae" works.
  In addition to partial UUID calling, jail TAG's can be used interchangeably.

  To ease jail identification a TAG field is included in list mode which can
  be set to any string (hostname, label, note, etc.). By default if unset the TAG field
  contains the creation date and time stamp.

  Properties are stored inside ZFS custom fields. This eliminates the need for
  any configuration files and jails can be easily moved with ZFS send and
  receive preserving all of their properties automatically.

  iocage relies on ZFS and at least one ZFS pool must be present on the host system.
  To enable all the features iocage supports,
  consider the following optional kernel options and system reqiurements:
    o   FreeBSD 10.0-RELEASE amd64 or higher
    o   bridge interfaces (bridge0,bridge1) add:

        cloned_interfaces="bridge0 bridge1" to /etc/rc.conf
    o  Kernel compiled with:

        options         VIMAGE
        options         RACCT
        options         RCTL

SUBCOMMANDS

  fetch [release=RELEASE | ftphost=ftp.hostname.org]

    Used for downloading and updating/patching releases.

    fetch must be executed as the first command on a pristine system. By
    default fetch will download the host node's RELEASE for deployment. If
    other releases are required, this can be changed by supplying the
    required release property or just selecting the appropriate RELEASE from
    the menu list.

    Example: iocage fetch release=9.2-RELEASE

    fetch is also used to update already downloaded releases. To update a local
    release already present in iocage (iocage list -r) run:

             iocage fetch release=10.1-RELEASE

    This example will apply latest patches to 10.1-RELEASE base.
    Newly created jails or basejails will automatically have the latest
    latest updates applied.

  create [-b|-c|-e] [release=RELEASE] [property=value] [property=value]

    By default create will deploy a new jail based on the host operating
    system's release. This can be changed by specifying the release option.
    If the -c switch is specified the jail will be cloned from the current
    hosts RELEASE (uname -r).
    Default is to create a fully independent jail set.
    The -e switch will create an empty jail which can be used for unsupported or
    custom jails.
    The -b flag will create a so called "basejail" with a common shared base.

    Example: iocage create tag=www01 pkglist=$HOME/my-pkgs.txt
             iocage create -b tag=mybasejail

  clone UUID|TAG [UUID|TAG@snapshot] [property=value]

    Clone jail identified by UUID (ZFS clone). All properties will be reset on
    the clone, defaults can be overridden by specifying properties on the fly.
    Custom point-in-time snapshots can be used as a source for cloning in the
    form of UUID@snapshot or TAG@snapshot.

    Examples:

    Clone the current state of the jail:
    iocage clone UUID tag=www02

    Clone a jail from a custom snapshot (snapshot taken previously):
    iocage clone UUID@snapshotname tag=www02

  destroy UUID|TAG

    Destroy given jail. This is irreversible, use with caution. If the jail is
    running destroy action will fail. Also a capital "Y" is required for confirmation.

  list [-t|-r]

    List all jails, if -t is specified list only templates, with -r list downloaded
    releases.
    Non iocage jail listed, only if jail in UP state.

  df

    List disk space related information. Available fields:

    CRT - compression ratio
    RES - reserved space
    QTA - disk quota
    USE - used space
    AVA - available space

  start UUID|TAG

    Start jail identified by UUID or TAG.

  stop UUID|TAG

    Stop jail identified by UUID or TAG.

  restart UUID|TAG

    Soft restart jail. Soft method will restart the jail without destroying
    the jail's networking and the jail process itself. All processes are gracefully
    restarted inside the jail. Useful for quick and graceful restarts.

  rcboot

    Start all jails with "boot" property set to "on". Intended for boot time
    execution. Jails will be started in an ordered fashion based on their
    "priority" property.

  rcshutdown

    Stop all jails with "boot" property set to "on". Intended for full host shutdown.
    Jails will be stopped in an ordered fashion based on their "priority"
    property.

  console UUID|TAG

    Console access, drop into jail.

  exec [-u username | -U username] UUID command [arg ...]

    Execute command inside the jail. This is simply an iocage UUID/tag wrapper
    for jexec(8).

  chroot UUID|TAG [command]

    Chroot into jail, without actually starting the jail itself. Useful for
    initial setup (set root password, configure networking). You can specify a
    command just like with the normal system chroot tool.

  show property

    Shows the given property for all jails and templates. Useful to compare
    settings/properties for all jails.

    To get the last successfull start time for all jails:

        iocage show last_started

  get property|all UUID|TAG

    Get named property or if "all" keyword is specified dump all properties known to
    iocage.

    To display whether resource limits are enforced for a jail:

    iocage get rlimits UUID|TAG

  set property=value UUID|TAG

    Set a property to value.

  cap UUID|TAG

    Reapply resource limits on jail while it is running.

  limits [UUID|TAG]

    Display active resource limits for a jail or all jails. With no UUID supplied
    display all limits active for all jail.

  uncap UUID|TAG

    Release all resource limits, disable limits on the fly.

  inuse UUID|TAG

    Display consumed resources for a jail.

  snapshot UUID|TAG [UUID|TAG@snapshotname]

    Create a ZFS snapshot for jail. If no snapshot name is specified defaults
    to auto snapshot name based on current date and time.

  snaplist UUID|TAG

    List all snapshots belonging to jail.

        NAME    - snapshot name
        CREATED - creation time
        RSIZE   - referenced size
        USED    - used space

  snapremove UUID|TAG@snapshotname

    Destroy specified jail snapshot.

  rollback UUID|TAG@snapshotname

    Rollback to an existing snapshot. Any intermediate snapshots will be
    destroyed. For more information on this functionality please read zfs(8).

  promote UUID|TAG

    Promote a cloned jail to a fully independent copy. For more details please
    read zfs(8).

  runtime UUID|TAG

    Show runtime configuration of a jail. Useful for debugging.

  update UUID|TAG

    Update jail to latest patch level. A back-out snapshot is created to allow
    safe update/rollback.

  upgrade UUID|TAG [release=RELEASE]

    By default this will upgrade jail RELEASE to match the host's RELEASE
    unless another RELEASE is specified with the "release" property.

    Please note: Upgrading basejails is done by setting the jail's "release"
    property to the required new RELEASE:

    iocage set release=10.1-RELEASE UUID|TAG

    For this the RELEASE must be locally available. The basejail
    will re-clone its filesystems from the new release either by issuing
    the upgrade command or at next jail start.

  record start|stop UUID|TAG

    The record function will record every changed file in a directory called
    /iocage/jails/UUID/recorded. This is achieved by using a unionfs overlay
    mount. Used for differential package creation.

  package UUID|TAG

    Package recorded jail session into /iocage/packages. Creates SHA256
    checksum and prunes empty directories, files and some residual files like
    utx.* and .history. Before packaging any jails, make sure no unwanted files
    contaminated or leaked into the recorded package.

  export UUID|TAG

    Export a complete jail. An archive file is created in /iocage/images with SHA256
    checksum. Jail must be in stopped state before exporting.

  import UUID [property=value]

    Import full jail images or differential packages. Images need to be
    present in /iocage/images and packages in /iocage/packages along with
    along with checksum files. You can use short UUIDs - do not specify the
    the full filename only the UUID.

  defaults

    Display all defaults set in iocage itself.

  version | --version

    List version number.

  help

    List quick help.
PROPERTIES
  For more information on properties please check the relevant man page which
  is noted under each property in the form of "Source: manpage". Source "local"
  marks iocage specific properties.

  pkglist=none | path-to-file

    A text file containing one package per line. These will be auto installed when
    a jail is created. Works only in combination with the create subcommand.

    Default: none
    Source: local

  vnet=on | off

    This controls whether to start the jail with VNET or a shared IP
    configuration. Default is to auto-guess from a sysctl. If you don't
    need a fully virtualized per jail network stack set it to off.

    Default: auto-guess
    Source: local

  ip4_addr="interface|ip-address/netmask"

    The IPv4 address for VNET and shared IP jails.

    Form is: interface|ip-address/netmask
    Multiple interfaces:
    "interface|ip-address/netmask,interface|ip-address/netmask"

    For shared IP jails if an interface is given before
    the IP address, an alias for the address will be added to that
    interface, as it is with the interface parameter.  If a netmask
    in either dotted-quad or CIDR form is given after IP address, it
    will be used when adding the IP alias.

    For VNET jails the interface will be configured with the IP addresses
    listed.

    Example: "vnet0|192.168.0.10/24,vnet1|10.1.1.10/24"
    This would configure interfaces vnet0 and vnet1 in a VNET jail. In this
    case no network configuration is necessary in the jail's rc.conf file.

    Default: none
    Source: jail(8)

  ip4_saddrsel=1 | 0

    Only takes effect when vnet=off.
    A boolean option to change the formerly mentioned behaviour and
    disable IPv4 source address selection for the prison in favour of
    the primary IPv4 address of the jail.  Source address selection
    is enabled by default for all jails and the ip4_nosaddrsel
    settting of a parent jail is not inherited for any child jails.

    Default: 1
    Source: jail(8)

  ip4=new | disable | inherit

    Only takes effect when vnet=off.
    Control the availability of IPv4 addresses.  Possible values are
    "inherit" to allow unrestricted access to all system addresses,
    "new" to restrict addresses via ip4.addr above, and "disable" to
    stop the jail from using IPv4 entirely.  Setting the ip4.addr
    parameter implies a value of "new".

    Default: new
    Source: jail(8)

  defaultrouter=none | ipaddress

    Setting this property to anything other than none will try to configure a
    default route inside a VNET jail.

  defaultrouter6=none | ip6address

    Setting this property to anything other than none will try to configure a
    default IPv6 route inside a VNET jail.

  ip6.addr, ip6.saddrsel, ip6
    A set of IPv6 options for the prison, the counterparts to
    ip4.addr, ip4.saddrsel and ip4 above.

  interfaces=vnet0:bridge0,vnet1:bridge1 | vnet0:bridge0

    By default there are two interfaces specified with their bridge
    association. Up to four interfaces are supported. Interface configurations
    are separated by commas. Format is interface:bridge, where left value is
    the virtual VNET interface name, right value is the bridge name where the
    virtual interface should be attached.

    Default: vnet0:bridge0,vnet1:bridge1
    Source: local

  host_hostname=UUID

    The hostname of the jail.

    Default: UUID
    Source: jail(8)

  exec_fib=0 | 1 ..

    The FIB (routing table) to set when running commands inside the jail.

    Default: 0
    Source: jail(8)

  devfs_ruleset=4 | 0 ..

    The number of the devfs ruleset that is enforced for mounting
    devfs in this jail.  A value of zero (default) means no ruleset
    is enforced.  Descendant jails inherit the parent jail's devfs
    ruleset enforcement.  Mounting devfs inside a jail is possible
    only if the allow_mount and allow_mount_devfs permissions are
    effective and enforce_statfs is set to a value lower than 2.
    Devfs rules and rulesets cannot be viewed or modified from inside
    a jail.

    NOTE: It is important that only appropriate device nodes in devfs
    be exposed to a jail; access to disk devices in the jail may permit
    processes in the jail to bypass the jail sandboxing by modifying
    files outside of the jail.  See devfs(8) for information on
    how to use devfs rules to limit access to entries in the per-jail
    devfs.  A simple devfs ruleset for jails is available as ruleset
    #4 in /etc/defaults/devfs.rules

    Default: 4
    Source: jail(8)

  mount_devfs=1 | 0

    Mount a devfs(5) filesystem on the chrooted /dev directory, and
    apply the ruleset in the devfs_ruleset parameter (or a default of
    ruleset 4: devfsrules_jail) to restrict the devices visible
    inside the jail.

    Default: 1
    Source: jail(8)

  exec_start="/bin/sh /etc/rc"

    Command(s) to run in the prison environment when a jail is created.
    A typical command to run is "sh /etc/rc".

    Default: /bin/sh /etc/rc
    Source: jail(8)

  exec_stop="/bin/sh /etc/rc.shutdown"

    Command(s) to run in the prison environment before a jail is
    removed, and after any exec_prestop commands have completed.
    A typical command to run is "sh /etc/rc.shutdown".

    Default: /bin/sh /etc/rc.shutdown
    Source: jail(8)

  exec_prestart="/usr/bin/true"

    Command(s) to run in the system environment before a jail is started.

    Default: /usr/bin/true
    Source: jail(8)

  exec_prestop="/usr/bin/true"

    Command(s) to run in the system environment before a jail is stopped.

    Default: /usr/bin/true
    Source: jail(8)

  exec_poststop="/usr/bin/true"

    Command(s) to run in the system environment after a jail is stopped.

    Default: /usr/bin/true
    Source: jail(8)

  exec_poststart="/usr/bin/true"

    Command(s) to run in the system environment after a jail is started,
    and after any exec_start commands have completed.

    Default: /usr/bin/true
    Source: jail(8)

  exec_clean=1 | 0

    Run commands in a clean environment.  The environment is discarded
    except for HOME, SHELL, TERM and USER.  HOME and SHELL are
    set to the target login's default values.  USER is set to the
    target login.  TERM is imported from the current environment.
    The environment variables from the login class capability database
    for the target login are also set.

    Default: 1
    Source: jail(8)

  exec_timeout=60 | 30 ..

    The maximum amount of time to wait for a command to complete.  If
    a command is still running after this many seconds have passed,
    the jail will be terminated.

    Default: 60
    Source: jail(8)

  stop_timeout=30 | 60 ..

    The maximum amount of time to wait for a jail's processes to
    exit after sending them a SIGTERM signal (which happens after the
    exec_stop commands have completed).  After this many seconds have
    passed, the jail will be removed, which will kill any remaining
    processes. If this is set to zero, no SIGTERM is sent and the
    prison is immediately removed.

    Default: 30
    Source: jail(8)

  exec_jail_user=root

    The user to run commands as, when running in the jail environment.

    Default: root
    Source:  jail(8)

  exec_system_jail_user=0 | 1

    This boolean option looks for the exec_jail_user in the system
    passwd(5) file, instead of in the jail's file.

    Default: 0
    Source: jail(8)

  exec_system_user=root

    The user to run commands as, when running in the system environment.
    The default is to run the commands as the current user.

    Default: root
    Source: jail(8)

  mount_fdescfs=1 | 0

    Mount a fdescfs(5) filesystem in the jail's /dev/fd directory.
    Note: This is not supported on FreeBSD 9.3.

    Default: 1
    Source: jail(8)

  mount_procfs=0 | 1

    Mount a procfs(5) filesystem in the jail's /dev/proc directory.

    Default: 0
    Source: local

  enforce_statfs=2 | 1 | 0

    This determines which information processes in a jail are able to
    get about mount points.  It affects the behaviour of the following
    syscalls: statfs(2), fstatfs(2), getfsstat(2) and fhstatfs(2)
    (as well as similar compatibility syscalls).  When set to 0, all
    mount points are available without any restrictions.  When set to 1,
    only mount points below the jail's chroot directory are visible
    In addition to that, the path to the jail's chroot directory
    is removed from the front of their pathnames.  When set to 2
    (default), above syscalls can operate only on a mount-point where
    the jail's chroot directory is located.

    Default: 2. jail(8)

  children_max=0 | ..

    The number of child jails allowed to be created by this jail (or
    by other jails under this jail). This limit is zero by default,
    indicating the jail is not allowed to create child jails.  See
    the Hierarchical Jails section for more information in jail(8).

    Default: 0
    Source: jail(8)

  login_flags="-f root"

    Supply these flags to login when logging in to jails with the console function.

    Default: -f root
    Source: login(1)

  jail_zfs=on | off

    Enables automatic ZFS jailing inside the jail. Assigned ZFS dataset will
    be fully controlled by the jail.
    NOTE: Setting this to "on" automatically enables allow_mount=1
    enforce_statfs=1 and allow_mount_zfs=1! These are dependent options
    required for ZFS management inside a jail.

    Default: off
    Source: local

  jail_zfs_dataset=iocage/jails/UUID/root/data | zfs_filesystem

    This is the dataset to be jailed and fully handed over to a jail. Takes
    the ZFS filesystem name without pool name.
    NOTE: only valid if jail_zfs=on. By default the mountpoint is set to none,
    to mount this dataset set its mountpoint inside the jail i.e. "zfs set
    mountpoint=/data full-dataset-name" and issue "mount -a".

    Default: iocage/jails/UUID/root/data
    Source: local

  securelevel=3 | 2 | 1 | 0 | -1

    The value of the jail's kern.securelevel sysctl.  A jail never
    has a lower securelevel than the default system, but by setting
    this parameter it may have a higher one.  If the system
    securelevel is changed, any jail securelevels will be at least as
    secure.

    Default: 2
    Source: jail(8)

  allow_set_hostname=1 | 0

    The jail's hostname may be changed via hostname(1) or sethostname(3).

    Default: 1
    Source: jail(8)

  allow_sysvipc=0 | 1

    A process within the jail has access to System V IPC
    primitives.  In the current jail implementation, System V
    primitives share a single namespace across the host and
    jail environments, meaning that processes within a jail
    would be able to communicate with (and potentially interfere
    with) processes outside of the jail, and in other jails.

    Default: 0
    Source: jail(8)

  allow_raw_sockets=0 | 1

    The prison root is allowed to create raw sockets.  Setting
    this parameter allows utilities like ping(8) and
    traceroute(8) to operate inside the prison.  If this is
    set, the source IP addresses are enforced to comply with
    the IP address bound to the jail, regardless of whether
    or not the IP_HDRINCL flag has been set on the socket.
    Since raw sockets can be used to configure and interact
    with various network subsystems, extra caution should be
    used where privileged access to jails is given out to
    untrusted parties.

    Default: 0
    Source: jail(8)

  allow_chflags=0 | 1

    Normally, privileged users inside a jail are treated as
    unprivileged by chflags(2).  When this parameter is set,
    such users are treated as privileged, and may manipulate
    system file flags subject to the usual constraints on
    kern.securelevel.

    Default: 0
    Source: jail(8)

  allow_mount=0 | 1

    privileged users inside the jail will be able to mount
    and unmount file system types marked as jail-friendly.
    The lsvfs(1) command can be used to find file system
    types available for mount from within a jail.  This permission
    is effective only if enforce_statfs is set to a
    value lower than 2.

    Default: 0
    Source: jail(8)

  allow_mount_devfs=0 | 1

    privileged users inside the jail will be able to mount
    and unmount the devfs file system.  This permission is
    effective only together with allow.mount and if
    enforce_statfs is set to a value lower than 2.  Please
    consider restricting the devfs ruleset with the
    devfs_ruleset option.

    Default: 0
    Source: jail(8)

  allow_mount_nullfs=0 | 1

    privileged users inside the jail will be able to mount
    and unmount the nullfs file system. This permission is
    effective only together with allow_mount and if
    enforce_statfs is set to a value lower than 2.

    Default: 0
    Source: jail(8)

  allow_mount_procfs=0 | 1

    privileged users inside the jail will be able to mount
    and unmount the procfs file system.  This permission is
    effective only together with allow.mount and if
    enforce_statfs is set to a value lower than 2.

    Default: 0
    Source: jail(8)

  allow_mount_tmpfs=0 | 1

    privileged users inside the jail will be able to mount
    and unmount the tmpfs file system.  This permission is
    effective only together with allow.mount and if
    enforce_statfs is set to a value lower than 2.
    Note: This is not supported on FreeBSD 9.3.

    Default: 0
    Source: jail(8)

  allow_mount_zfs=0 | 1

    privileged users inside the jail will be able to mount
    and unmount the ZFS file system.  This permission is
    effective only together with allow.mount and if
    enforce_statfs is set to a value lower than 2.  See
    zfs(8) for information on how to configure the ZFS
    filesystem to operate from within a jail.

    Default: 0
    Source: jail(8)

  allow_quotas=0 | 1

    The jail root may administer quotas on the jail's
    filesystem(s). This includes filesystems that the jail
    may share with other jails or with non-jailed parts of
    the system.

    Default: 0
    Source: jail(8)

  allow_socket_af=0 | 1

    Sockets within a jail are normally restricted to IPv4,
    IPv6, local (UNIX), and route.  This allows access to
    other protocol stacks that have not had jail functionality
    added to them.

    Default: 0
    Source: jail(8)

  host_hostuuid=UUID

    Default: UUID
    Source: jail(8)

  tag="any string"

    Custom string for aliasing jails.

    Default: date@time
    Source: local

  template=yes | no

    This property controls whether the jail is a template. Templates are not
    started by iocage. Set to yes if you intend to convert jail into template.
    (See EXAMPLES section)

    Default: no
    Source: local

  boot=on | off

    If set to "on" jail will be auto-started at boot time (rcboot subcommand)
    and stopped at shutdown time (rcshutdown subcommand). Jails will be started
    and stopped based on their priority value.

    Default: off
    Source: local

  notes="any string"

    Custom notes for miscelanious tagging.

    Default: none
    Source: local

  owner=root

    The owner of the jail, can be any string.

    Default: root
    Source: local

  priority=99 | 50 ..

    Start priority at boot time, smaller value means higher priority.
    Also, for shutdown the order will be reversed.

    Default: 99.

  last_started

    Last successful start time. Auto set every time jail starts.

    Default: timestamp
    Source: local

  type=jail

    Currently only jail is supported - this is for future use.

    Default: jail
    Source: local

  hostid=UUID

    The UUID of the host node. Jails won't start if this property differs from the actual UUID
    of the host node. This is to safeguard jails from being started on
    different nodes in case they are periodically replicated across.

    Default: UUID of the host (taken from /etc/hostid)
    Source: local

  release=10.0-RELEASE | 9.2-RELEASE

    The RELEASE used at creation time. Can be set to any string if needed.

    Default: the host's RELEASE
    Source: local

  compression=on | off | lzjb | gzip | gzip-N | zle | lz4

    Controls the compression algorithm used for this dataset. The lzjb
    compression algorithm is optimized for performance while providing
    decent data compression. Setting compression to on uses the lzjb compression
    algorithm. The gzip compression algorithm uses the same compression
    as the gzip(1) command. You can specify the gzip level by
    using the value gzip-N where N is an integer from 1 (fastest) to 9
    (best compression ratio). Currently, gzip is equivalent to gzip-6
    (which is also the default for gzip(1)).  The zle compression algorithm
    compresses runs of zeros.

    The lz4 compression algorithm is a high-performance replacement for
    the lzjb algorithm. It features significantly faster compression and
    decompression, as well as a moderately higher compression ratio than
    lzjb, but can only be used on pools with the lz4_compress feature set
    to enabled.  See zpool-features(7) for details on ZFS feature flags
    and the lz4_compress feature.

    This property can also be referred to by its shortened column name
    compress.  Changing this property affects only newly-written data.

    Default: lz4
    Source: zfs(8)

  origin

    This is only set for clones. Read-only.
    For cloned file systems or volumes, the snapshot from which the clone
    was created. See also the clones property.

    Default: -
    Source: zfs(8)

  quota=15G | 50G | ..

    Quota for jail.
    Limits the amount of space a dataset and its descendents can consume.
    This property enforces a hard limit on the amount of space used. This
    includes all space consumed by descendents, including file systems
    and snapshots. Setting a quota on a descendent of a dataset that
    already has a quota does not override the ancestor's quota, but
    rather imposes an additional limit.

    Default: none
    Source: zfs(8)

  mountpoint

    Path for the jail's root filesystem. Don't tweak this or jail won't start!

    Default: set to jail's root
    Source: zfs(8)

  compressratio

    Compression ratio. Read-only.
    For non-snapshots, the compression ratio achieved for the used space
    of this dataset, expressed as a multiplier.  The used property
    includes descendant datasets, and, for clones, does not include the
    space shared with the origin snapshot.

    Source: zfs(8)

  available

    Available space in jail's dataset.
    The amount of space available to the dataset and all its children,
    assuming that there is no other activity in the pool. Because space
    is shared within a pool, availability can be limited by any number of
    factors, including physical pool size, quotas, reservations, or other
    datasets within the pool.

    Source: zfs(8)

  used

    Used space by jail. Read-only.
    The amount of space consumed by this dataset and all its descendents.
    This is the value that is checked against this dataset's quota and
    reservation. The space used does not include this dataset's reservation,
    but does take into account the reservations of any descendent
    datasets. The amount of space that a dataset consumes from its parent,
    as well as the amount of space that are freed if this dataset is
    recursively destroyed, is the greater of its space used and its
    reservation.

    When snapshots (see the "Snapshots" section) are created, their space
    is initially shared between the snapshot and the file system, and
    possibly with previous snapshots. As the file system changes, space
    that was previously shared becomes unique to the snapshot, and
    counted in the snapshot's space used. Additionally, deleting snapshots
    can increase the amount of space unique to (and used by) other
    snapshots.

    The amount of space used, available, or referenced does not take into
    account pending changes. Pending changes are generally accounted for
    within a few seconds. Committing a change to a disk using fsync(2) or
    O_SYNC does not necessarily guarantee that the space usage information
    is updated immediately.

    Source:  zfs(8)

  dedup=on | off | verify | sha256[,verify]

    Deduplication for jail.
    Configures deduplication for a dataset. The default value is off.
    The default deduplication checksum is sha256 (this may change in the
    future).  When dedup is enabled, the checksum defined here overrides
    the checksum property. Setting the value to verify has the same
    effect as the setting sha256,verify.

    If set to verify, ZFS will do a byte-to-byte comparsion in case of
    two blocks having the same signature to make sure the block contents
    are identical.

    Default: off.
    Source: zfs(8)

  reservation=size | none

    Reserved space for jail.
    The minimum amount of space guaranteed to a dataset and its descendents.
    When the amount of space used is below this value, the dataset
    is treated as if it were taking up the amount of space specified by
    its reservation. Reservations are accounted for in the parent
    datasets' space used, and count against the parent datasets' quotas
    and reservations.

    Default: none
    Source: zfs(8)

  sync_target

    This is for future use, currently not supported.

  sync_tgt_zpool

    This is for future use, currently not supported.

  rlimits=on | off

    If set to "on" resource limits will be enforced.

    Default: off
    Source: local

  cpuset=1 | 1,2,3,4 | 1-2 | off

    Controls the jail's CPU affinity. For more details please refer to cpuset(1).

    Default: off
    Source: cpuset(1)
RESOURCE LIMITS
  Resource limits (except cpuset and rlimits) use the following value
  field formatting in the property: limit:action.

  Limit defines how much of the resource a process can use before the
  defined action triggers.

  Action defines what will happen when a process exceeds the allowed
  amount.

  Valid actions are:
        deny    deny the allocation; not supported for cpu and
                wallclock
        log     log a warning to the console
        devctl  send notification to devd(8)
        sig*    e.g. sigterm; send a signal to the offending
                process

  To better understand what this means please read rctl(8)
  before enabling any limits.

  The following resource limits are supported:

  memoryuse=limit:action | off

    Limits the resident set size (DRAM).

    Default: 8G:log
    Source: rctl(8)

  memorylocked=limit:action | off

    Limits locked memory.

    Default: off
    Source: rctl(8)

  vmemoryuse=limit:action | off

    Virtual memory limit (swap + DRAM combined)

    Default: off
    Source: rctl(8)

  maxproc=limit:action | off

    Limit maximum number of processes.

    Default: off
    Source: rctl(8)

  cputime=limit:action | off

    Limit CPU time, in seconds.

    Default: off
    Source: rctl(8)

  pcpu=limit:action | off

    Limit %CPU, in percents of a single CPU core or hardware thread.

    Default: off
    Source: rctl(8)

  datasize=limit:action | off

    Limit data size.

    Default: off
    Source: rctl(8)

  stacksize=limit:action | off

    Limit stack size.

    Default: off
    Source: rctl(8)

  coredumpsize=limit:action | off

    Limit core dump size.

    Default: off
    Source: rctl(8)

  openfiles=limit:action | off

    Limit file descriptor table size (number of open files).

    Default: off
    Source: rctl(8)

  pseudoterminals=limit:action | off

    Limit number of PTYs.

    Default: off
    Source: rctl(8)

  swapuse=limit:action | off

    Limit swap usage.

    Default: off
    Source: rctl(8)

  nthr=limit:action | off

    Limit number of threads.

    Default: off
    Source: rctl(8)

  msgqqueued=limit:action | off

    Limit number of queued SysV messages.

    Default: off
    Source: rctl(8)

  msgqsize=limit:action | off

    Limit SysV message queue size.

    Default: off
    Source: rctl(8)

  nmsgq=limit:action | off

    Limit number of SysV message queues.

    Default: off
    Source: rctl(8)

  nsemop=limit:action | off

    Limit number of SysV semaphores modified in a single semop(2) call.

    Default: off
    Source: rctl(8)

  nshm=limit:action | off

    Limit number of SysV shared memory segments.

    Default: off
    Source: rctl(8)

  shmsize=limit:action | off

    Limit SysV shared memory size.

    Default: off
    Source: rctl(8)

  wallclock=limit:action | off

    Limit wallclock time.

    Default: off
    Source: rctl(8)

EXAMPLES
  Set up iocage from scratch:

    iocage fetch

  Create first jail:

    iocage create tag=myjail

  List jails:

    iocage list

  Start jail:

    iocage start UUID

  Turn on resource limits and apply them:

    iocage set rlimits=on UUID
    iocage cap UUID

  Display resource usage:

    iocage inuse UUID

  Convert jail into template:

    iocage set template=yes UUID

  List templates:

    iocage list -t

  Clone jail from template:

    iocage clone UUID-of-template tag=myjail

  Record all changeing files in a jail

    iocage record start UUID

  Stop recording

    iocage record stop UUID

  Create package from recorded session

    iocage package UUID

  Import package on another host

    iocage import UUID

  Get the last successful start time for all jails

    iocage show last_started
HINTS
  iocage marks a ZFS pool in the pool's comment field and identifies the
  active pool for use based on this string.

  If using VNET don't forget to add the node's physical NIC into one
  of the bridges if you need an outside connection. Also read bridge(4)
  to see how traffic is handled if you are not familiar with this concept
  (in a nutshell: bridge behaves like a network switch).

  PF firewall is not supported inside VNET jails as of July 2014. PF can be
  enabled for the host however. IPFW is fully supported inside a VNET jail.

  Property validation is not handled by iocage (to keep it simple) so please
  make sure your property values are supported before configuring any
  properties.

  The actual jail name in the jls(8) output is set to ioc-UUID. This is a
  required workaround as jails will refuse to start with jail(8) when name
  starts with a "0".

  To prevent dmesg leak inside jails apply the following sysctl:

    security.bsd.unprivileged_read_msgbuf=0

  If using VNET consider applying these sysctl's as well:

    net.inet.ip.forwarding=1
    net.link.bridge.pfil_onlyip=0
    net.link.bridge.pfil_bridge=0
    net.link.bridge.pfil_member=0

  For more information please visit:

    http://pannon.github.io/iocage/

SEE ALSO
  jail(8), ifconfig(8), epair(4), bridge(4), jexec(8), zfs(8), zpool(8),
  rctl(8), cpuset(1), freebsd-update(8), sysctl(8)
BUGS
  In case of bugs/issues/feature requests, please open an issue at
  https://github.com/pannon/iocage/issues
AUTHORS
  Peter Toth <peter.toth198@gmail.com>
  Brandon Schneider <brandonschneider89@gmail.com>
SPECIAL THANKS
  Sichendra Bista - for his ever willing attitude and ideas.
EOT
}


if [ -z "$1" ] ; then
    __usage
    exit 0
fi

if [ "$1" == "help" ] ; then
    __help
    exit 0
fi


if [ "$(whoami)" != "root" ] ; then
    echo "* Only root can manage jails!"
    exit 1
fi

__find_mypool
__parse_cmd "$@"
